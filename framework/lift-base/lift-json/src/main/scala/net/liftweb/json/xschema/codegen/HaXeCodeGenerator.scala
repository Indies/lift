package net.liftweb.json.xschema.codegen

import _root_.net.liftweb.json.JsonParser
import _root_.net.liftweb.json.JsonAST._
import _root_.net.liftweb.json.Printer._
import _root_.net.liftweb.json.xschema._
import _root_.net.liftweb.json.xschema.XSchemaTree._
import _root_.net.liftweb.json.xschema.Serialization._

import java.io.{Writer}


object HaXeCodeGenerator extends CodeGeneratorCLI {
  val generator = new BaseHaXeCodeGenerator
}

class BaseHaXeCodeGenerator extends CodeGenerator with CodeGeneratorHelpers {
  def generate(root: XRoot, destPathCode: String, destPathTests: String, namespaceSpec: List[String], writerF: String => Writer) = {
    val includeSchemas = extractBoolProperty(root.properties, PredefinedProperties.XSchemaIncludeSchemas, true)

    val bundle      = CodeBundle.empty
    val testBundle  = CodeBundle.empty
    
    implicit val database = XSchemaDatabase(root.definitions, root.constants)
    
    val namespaces  = (if (namespaceSpec.length == 0) database.namespaces else namespaceSpec)
    
    for (namespace <- namespaces) {
      val code = CodeBuilder.empty
      val test = CodeBuilder.empty

      buildCodeFor(namespace, code, root, includeSchemas)
      //buildTestFor(namespace, test, root, includeSchemas)

      bundle += toFile(namespace, "Data", "hx")         -> code
      testBundle += toFile(namespace, "DataTest", "hx") -> test
    }

    bundle.create(destPathCode, writerF)
    testBundle.create(destPathTests, writerF)
  }
  
  private def extractBoolProperty(map: Map[String, JValue], prop: String, default: Boolean) = map.get(prop) match {
    case None => false
    case Some(v) => v match {
      case JBool(b) => b
      case x => error("Expected bool but found: " + x)
    }
  }
  
  private def extractListProperty(map: Map[String, JValue], prop: String): List[String] = map.get(prop) match {
    case None => Nil
    
    case Some(v) => v match {
      case JArray(list) => list.flatMap {
        case JString(s) => s :: Nil
        case x => error("Expected array of strings for " + prop + " property but found: " + x)
      }
      
      case JString(item) => item :: Nil
    
      case _ => error("Expected string or array of strings for " + prop + " property")
    }
  }
  
  private def buildCodeFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    code.addln("// This code was auto-generated by Lift Json XSchema - do not edit").
         addln("// Note: Requires the Stax standard library for HaXe")
    
    code.add("""
      package ${namespace};
      
      import Prelude;
      import haxe.text.json.JValue;
      import haxe.data.transcode.Transcode;
      import haxe.data.transcode.JValue;
      import haxe.abstract.PartialFunction;
      import haxe.data.collections.Set;
      import haxe.data.collections.Map;
      import haxe.data.collections.List;
      
      using Prelude;
      using haxe.text.json.JValue;
      using haxe.data.transcode.JValue;
      using haxe.abstract.PartialFunction;""",
      
      "namespace" -> namespace
    ).newline(2)
    
    code.newline(2)
  
    code.join(database.definitionsIn(namespace), code.newline.newline) { definition =>
      buildDataFor(definition, code, includeSchemas)
    }
    
    buildConstantsFor(namespace, code)
  }
  
  /*private def buildTestFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    code.addln("// These tests were auto-generated by Lift Json XSchema - do not edit").
         addln("// Note: Requires the Stax standard library for HaXe")
    
    code.using("namespace" -> namespace, "package" -> namespace) {
      code.add("""
        package ${namespace};
        
        import Prelude;
        import haxe.text.json.JValue;
        import haxe.data.transcode.JValue;
        import haxe.data.collections.Set;
        import haxe.data.collections.Map;
        import haxe.data.collections.List;

        using Prelude;
        using haxe.text.json.JValue;
        using haxe.data.transcode.JValue;
        
        import ${namespace}.Data;
      """).newline
      
      buildSerializationTestFor(namespace, code, root, includeSchemas)
    }
  }*/
  
  private def buildSerializationTestFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    // For every product we generate some test data constructed by 
    // deserializing the product from nothing:
    /*
    code.newline.add("object ExampleProductData ").block {
      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo), "extractor" -> getExtractorFor(defn.referenceTo)) {
          defn match { 
            case x: XProduct if (x.isSingleton) => 
              // Due to apparent bug in HaXe compiler (implicits for singleton types), we must treat this case specially:
              code.add("lazy val Example${name}: ${type} = ${extractor}.extract(JObject(Nil))")
          
            case x: XProduct => 
              code.add("lazy val Example${name}: ${type} = JObject(Nil).deserialize[${type}]")
          }
        }
      }
    }
    
    // For every product, we test both serialization & deserialization (in basic ways):
    code.newline.addln("class DataProductSerializationTest extends Runner(DataProductSerializationExamples) with JUnit")
    
    code.add("object DataProductSerializationExamples extends Specification ").block {
      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.add("""
            "Deserialization of ${name} succeeds even when information is missing" in {
              ExampleProductData.Example${name}.isInstanceOf[${type}] must be (true)
            }""").newline
          
          if (defn.isSingleton) {
            code.add("""
              "Serialization of ${name} has non-zero information content" in {
                Decomposers.${name}Decomposer.decompose(ExampleProductData.Example${name}) mustNot be (JObject(Nil))
              }""")
          }
          else {
            code.add("""
              "Serialization of ${name} has non-zero information content" in {
                ExampleProductData.Example${name}.serialize mustNot be (JObject(Nil))
              }
            """)
          }
        }
      }
    }
    
    // For every multitype, we generate some test data constructed by 
    // deserializing every product which is type-compatible with the multitype:
    code.newline.add("object ExampleMultitypeData ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.addln("""lazy val Example${name}: ${type} = JObject(Nil).deserialize[${type}]""")
          
          code.join(database.findProductTerms(defn), code.newline) { product =>   
            code.add("""lazy val Example${name}From${productName}: ${type} = JObject(JField("${productName}", ${productNamespace}.Decomposers.${productName}Decomposer.decompose(${productNamespace}.ExampleProductData.Example${productName})) :: Nil).deserialize[${type}]""",
              "productName"      -> product.name,
              "productNamespace" -> product.namespace
            )
          }
        }
      }
    }
    
    code.newline.addln("class DataCoproductSerializationTest extends Runner(DataCoproductSerializationExamples) with JUnit")
    
    code.add("object DataCoproductSerializationExamples extends Specification ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.add("""
            "Deserialization of ${name} succeeds even when information is missing" in {
              ExampleMultitypeData.Example${name}.isInstanceOf[${type}] must be (true)
            }            
            "Serialization of ${name} has non-zero information content" in {
              ExampleMultitypeData.Example${name}.serialize mustNot be (JObject(Nil))
            }
          """).newline
          
          code.join(database.findProductTerms(defn), code.newline) { product =>   
            code.add("""
              "Deserialization of ${name} (from ${productName}) succeeds" in {
                ExampleMultitypeData.Example${name}From${productName}.isInstanceOf[${type}] must be (true)
              }            
              "Serialization of ${name} (from ${productName}) has non-zero information content" in {
                ExampleMultitypeData.Example${name}From${productName}.serialize mustNot be (JObject(Nil))
              }""",
              "productName" -> product.name
            )
          }
        }
      }
    }
    
    code.newline.addln("class DataConstantsSerializationTest extends Runner(DataConstantsSerializationExamples) with JUnit")
    
    code.add("object DataConstantsSerializationExamples extends Specification ").block {
      code.join(database.constantsIn(namespace), code.newline.newline) { constant => 
        code.add("""
          "Deserialization of constant ${name} succeeds" in {
            Constants.${name}.serialize.deserialize[${type}] must be (Constants.${name})
          }
          "Serialization of constant ${name} has non-zero information content" in {
            Constants.${name}.serialize mustNot be (JObject(Nil))
          }
        """,
        "name" -> constant.name,
        "type" -> typeSignatureOf(constant.constantType)
        )
      }
    }*/
  }
  
  private def formCompleteExtensionClause(interfaces: List[String]) = interfaces match {
    case Nil => " "
    case xs => "implements " + xs.mkString(", implements ") + " "
  }
  
  private def buildDataFor(definition: XDefinition, code: CodeBuilder, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    def buildMultitypeTypeclasses(x: XMultitype) = {
      var leafTerms    = database.referencesOf(database.findLeafTerms(x))
      
      code.add("""
        public static function OrderT(${typeclassBindType}): Order<${type}> {
          var orderers: PartialFunction2<${type}, ${type}, Int> = [${orderCode}].toPartialFunction();
          
          return OrderTypeclass.create({compare: orderers.call});
        }
        public static function EqualT(${typeclassBindType}): Equal<${type}> {
          return OrderT(${typeclassBindValue});
        }
        public static function ShowT(${typeclassBindType}): Show<${type}> {
          var showers: PartialFunction<${type}, String> = [${showCode}].toPartialFunction();
          
          return ShowTypeclass.create({show: showers.call});
        }
        public static function HasherT(${typeclassBindType}): Hasher<${type}> {
          var hashers: PartialFunction<${type}, Int> = [${hashCode}].toPartialFunction();
          
          return HasherTypeclass.create({hash: hashers.call});
        }
        public static function ExtractorT(${typeclassBindType}): JExtractor<${type}> {
          var extractors: PartialFunction<Hash<JValue>, ${type}> = [${extractorCode}].toPartialFunction();
          
          return ExtractorTypeclass.create({
            extract: function(v: JValue): ${type} {
              var extract0 = function(v: JValue): ${type} {                
                var hash = v.extractHash();
                
                return extractors.call(hash);
              }
              
              try {
                return extract0(v);
              }
              catch (e: Dynamic) {
                return extract0(${defJson});
              }
            }
          });
        }
        public static function DecomposerT(${typeclassBindType}): JDecomposer<${type}> {
          var decomposers: PartialFunction<${type}, JValue> = [${decomposerCode}].toPartialFunction();
          
          return DecomposerTypeclass.create({decompose: decomposers.call});
        }""",
        "typeclassBindType" -> (if (x.isInstanceOf[XUnion]) "" else "c: Class<${type}>"),
        
        "typeclassBindValue" -> (if (x.isInstanceOf[XUnion]) "" else "${type}"),
        
        "defJson" -> renderHaXe(x.default),
        
        "orderCode" -> (
          for (term1 <- leafTerms; term2 <- leafTerms)
            yield {
              val typeSig1 = typeSignatureOf(term1)
              val typeSig2 = typeSignatureOf(term2)
              val index1   = leafTerms.indexOf(term1)
              val index2   = leafTerms.indexOf(term2)
              
                  "Tuple2.create(function(v1: ${type}, v2: ${type}): Bool {return v1.isInstanceOf(" + typeSig1 + ") && v2.isInstanceOf(" + typeSig2 + ");}, " + 
                  "function(v1: ${type}, v2: ${type}): Int {return " + 
                    (if (index1 == index2) getOrderFor(term1) + ".compare(cast v1, cast v2)" else if (index1 < index2) "-1" else "1") + 
                    ";})"
            }
        ).mkString(", "),
        
        "showCode" -> (leafTerms.map { term =>
          "Tuple2.create(function(v: ${type}): Bool {return v.isInstanceOf(" + typeSignatureOf(term) + ");}, " +
                        "function(v: ${type}): String {return " + getShowFor(term) + ".show(cast v);})"
        }).mkString(", "),
                        
        "hashCode" -> (leafTerms.map { term =>
          "Tuple2.create(function(v: ${type}): Bool {return v.isInstanceOf(" + typeSignatureOf(term) + ");}, " +
                        "function(v: ${type}): Int {return " + getHasherFor(term) + ".hash(cast v);})"
        }).mkString(", "),
        
        "extractorCode" -> (leafTerms.map { term =>
          "Tuple2.create(function(h: Hash<JValue>): Bool {return h.exists('" + getTypeHintFor(term) + "');}," +
                        "function(h: Hash<JValue>): ${type} {return " + getExtractorFor(term) + ".extract(h.get('" + getTypeHintFor(term) + "'));})"
        }).mkString(", "),
        
        "decomposerCode" -> (leafTerms.map { term =>
          "Tuple2.create(function(v: ${type}): Bool {return v.isInstanceOf(" + typeSignatureOf(term) + ");}, " +
                        "function(v: ${type}): JValue {return JObject([JField('" + getTypeHintFor(term) + "', " + getDecomposerFor(term) + ".decompose(cast v))]);})"
        }).mkString(", ")
      ).newline
    }
    def buildXSchema() = {
      code.add("public static var xschema: JValue = ${json};",
        "json" -> renderHaXe(definition.serialize)
      )
    }
    
    buildDocumentationFor(definition.properties, code)
    
    val definitionTraits = database.coproductContainersOf(definition).map { x => typeSignatureOf(x.referenceTo) } ::: extractListProperty(definition.properties, "haxe.class.traits")
    
    var isSingleton = definition match {
      case x: XProduct => x.isSingleton
      case _           => false
    }
    
    code.using("type" -> typeSignatureOf(definition.referenceTo), "name" -> definition.name) {
      definition match {
        case x: XProduct =>
          code.add("class ${name} ${extendsClause}",
            "extendsClause" -> formCompleteExtensionClause(definitionTraits)
          ).block {
            code.add("""
              public static function OrderT(): Order<${type}> {
                return OrderTypeclass.create({
                  compare: function(v1: ${type}, v2: ${type}): Int {
                    var comparisons: Array<Thunk<Int>> = [${orderCode}];
                    
                    for (thunk in comparisons) {
                      var c: Int = thunk();
                      
                      if (c != 0) return c;
                    }
                    
                    return 0;
                  }
                });
              }
              public static function EqualT(): Equal<${type}> {
                return OrderT();
              }
              public static function ShowT(): Show<${type}> {
                return ShowTypeclass.create({
                  show: function(v: ${type}): String {
                    var fields: Array<String> = [${showCode}];
                    
                    return '${name}(' + fields.mkString(', ') + ')';
                  }
                });
              }
              public static function HasherT(): Hasher<${type}> {
                var initialHash = 9901 * String.HasherT().hash('${type}.${name}');
                
                return HasherTypeclass.create({
                  hash: function(v: ${type}): Int {
                    var hashes: Array<Int> = [${hashCode}];
                    
                    var hash = initialHash;
                    
                    for (e in hashes) {
                      hash += (333667 * (e + 197192));
                    }
                    
                    return hash;
                  }
                });
              }
              public static function ExtractorT(): JExtractor<${type}> {
                return ExtractorTypeclass.create({
                  extract: function(v: JValue): ${type} {
                    return new ${type}(${extractorCode});
                  }
                });
              }
              public static function DecomposerT(): JDecomposer<${type}> {
                return DecomposerTypeclass.create({
                  decompose: function(v: ${type}): JValue {
                    return JObject([${decomposerCode}]);
                  }
                });
              }
            """,
              "orderCode" -> (x.realFields.filter(_.order != XOrderIgnore).map { field =>
                val sign = field.order match {
                  case XOrderAscending  => "1"
                  case XOrderDescending => "-1"
                  case XOrderIgnore     => "0"
                }
                
                "function(){return " + getOrderFor(field.fieldType) + ".compare(v1." + fieldNameOf(field.name) + ", v2." + fieldNameOf(field.name) + ") * " + sign + ";}"
              }).mkString(", "),
              
              "showCode" -> (x.realFields.map { field =>
                getShowFor(field.fieldType) + ".show(v." + fieldNameOf(field.name) + ")"
              }).mkString(", "),
              
              "hashCode" -> (x.realFields.map { field =>
                getHasherFor(field.fieldType) + ".hash(v." + fieldNameOf(field.name) + ")"
              }).mkString(", "),
              
              "decomposerCode" -> (x.realFields.map { field =>
                "JField('" + field.name + "', " + getDecomposerFor(field.fieldType) + ".decompose(v." + fieldNameOf(field.name) + ")" + ")"
              }).mkString(", "),
              
              "extractorCode" -> (x.realFields.map { field =>
                "v.extractFieldValue('" + field.name + "', " + getExtractorFor(field.fieldType) + ", " + renderHaXe(field.default) + ")"
              }).mkString(", ")
            ).newline
            
            // Build fields:
            code.join(x.terms, code.newline) { field =>
              code.add("public var ${fieldName} (default, null): ${fieldType};",
                "fieldName" -> fieldNameOf(field.name),
                "fieldType" -> typeSignatureOf(field.fieldType)
              )
            }
            
            if (x.realFields.length == 0) {
              code.newline(2).addln("public static var Instance: ${type} = new ${type}();");
            }
            
            val argsList = x.realFields.map { f => fieldNameOf(f.name) }.mkString(", ")
            val constructorArgs = (x.realFields.map { f =>
              fieldNameOf(f.name) + ": " + typeSignatureOf(f.fieldType)
            }).mkString(", ")
            
            // Build constructor:
            code.newline.add("public function new(${constructorArgs}) ", "constructorArgs" -> constructorArgs).block {
              code.join(x.terms, code.newline) { field => 
                code.using("fieldName" -> fieldNameOf(field.name), "fieldType" -> typeSignatureOf(field.fieldType)) {
                  code.add("this.${fieldName} = ${fieldValue};",
                    "fieldValue" -> (field match {
                      case x: XRealField => "${fieldName}"

                      case x: XViewField => 
                        val product = database.resolve(field.fieldType).asInstanceOf[XProduct]
                      
                        "new ${fieldType}(" + product.realFields.map { f => fieldNameOf(f.name) }.mkString(", ") + ")"

                      case x: XConstantField => getExtractorFor(x.fieldType) + ".extract(" + renderHaXe(x.default) + ")"
                    })
                  );
                }
              }
            }
            
            // Build "with" methods to create copies:
            code.newline(2).join(x.realFields, code.newline) { field =>
              code.add("public function with${withName}(${fieldName}: ${fieldType}): ${type} { return new ${name}(${argsList}); }", "argsList" -> argsList,
                "withName"  -> { var name = fieldNameOf(field.name); name.charAt(0).toUpperCase.toString + name.substring(1) },
                "fieldName" -> fieldNameOf(field.name),
                "fieldType" -> typeSignatureOf(field.fieldType)
              )
            }
            
            code.newline(2).add("""
              public function compare(that: ${type}): Int {
                return ${orderer}.compare(this, that);
              }
            """,
              "orderer" -> getOrderFor(x.referenceTo)
            )
          }
      
        case x: XCoproduct => 
          code.add("interface ${name} ${extendsClause}", "extendsClause" -> formCompleteExtensionClause(definitionTraits)).block {
            code.join(database.commonFieldsOf(x), code.newline) { common =>
              code.add("public var ${fieldName} (default, null): ${fieldType};",
                "fieldName" -> common._1,
                "fieldType" -> typeSignatureOf(common._2)
              )
            }
          }
          
          code.newline(2).add("class ${name}Extensions ").block {
            buildMultitypeTypeclasses(x)
          }
          
          case x: XUnion =>
            // HaXe has no clean representation for union types yet, so we just 
            // use a typedef to Dynamic:
            code.add("typedef ${name} = Dynamic")
            
            code.newline(2).add("class ${name}Extensions ").block {
              buildMultitypeTypeclasses(x)
            }
      }
    }
  }
  
  private def buildDocumentationFor(properties: Map[String, JValue], code: CodeBuilder): Unit = properties.get(PredefinedProperties.XSchemaDoc) match {
    case None => 
    case Some(v) => v match {
      case JString(doc) => code.add("/** ").wrap(doc.replaceAll("\\s+", " "), " * ", 80).newline.add(" */").newline
      case x => error("Expected string for documentation, but found: " + x)
    }
  }
  
  def getTypeHintFor(ref: XReference): String = ref match {
    case x: XPrimitiveRef => x match {
      case XString  => "String"
      case XInt     => "Int"
      case XLong    => "Int"
      case XFloat   => "Float"
      case XDouble  => "Float"
      case XBoolean => "Bool"
      case XJSON    => "JValue"
      case XDate    => "Date"
    }
    
    case x: XContainerRef => x match {
      case x: XCollection => x match {
        case x: XSet   => "Set"
        case x: XList  => "List"
        case x: XArray => "Array"
      }
      
      case x: XMap      => "Map"
      case x: XTuple    => "Tuple" + x.types.length
      case x: XOptional => "Option"
    }
    
    case x: XDefinitionRef => x.name
  }
  
  private def getTypeclassFor(typeclass: String, ref: XReference)(implicit database: XSchemaDatabase): String = {
    ref match {
      case x: XPrimitiveRef  => getTypeHintFor(ref) + "." + typeclass + "()"

      case x: XContainerRef => getTypeHintFor(ref) + "." + typeclass + "(" + (x match {
        case x: XSet        => getTypeclassFor(typeclass, x.elementType)      
        case x: XList       => getTypeclassFor(typeclass, x.elementType)      
        case x: XArray      => getTypeclassFor(typeclass, x.elementType)      
        case x: XMap        => getTypeclassFor(typeclass, x.keyType) + ", " + getTypeclassFor(typeclass, x.valueType)
        case x: XTuple      => x.types.map { x => getTypeclassFor(typeclass, x) }.mkString(", ")
        case x: XOptional   => getTypeclassFor(typeclass, x.optionalType)
      }) + ")"

      case x: XDefinitionRef => database.resolve(x) match {
        case t : XMultitype => 
          var classname = x.namespace + "." + getTypeHintFor(x);
          
          classname + "Extensions." + typeclass + "(" + (if (t.isInstanceOf[XUnion]) "" else classname) + ")"
        
        case _ => x.namespace + "." + getTypeHintFor(x) + "." + typeclass + "()"
      }
    }
  }
  
  private def getHasherFor(ref: XReference)(implicit database: XSchemaDatabase): String = getTypeclassFor("HasherT", ref)
  private def getEqualFor(ref: XReference)(implicit database: XSchemaDatabase): String = getTypeclassFor("EqualT", ref)
  private def getShowFor(ref: XReference)(implicit database: XSchemaDatabase): String = getTypeclassFor("ShowT", ref)
  private def getOrderFor(ref: XReference)(implicit database: XSchemaDatabase): String = getTypeclassFor("OrderT", ref)
  
  private def getDecomposerFor(ref: XReference)(implicit database: XSchemaDatabase): String = {
    ref match {
      case x: XPrimitiveRef  => getTypeHintFor(ref) + ".DecomposerT()"
      
      case x: XMap if (x.keyType == XString) => "haxe.data.collections.Map.StringKeyDecomposerT(" + getDecomposerFor(x.valueType) + ")"

      case x: XContainerRef => getTypeHintFor(ref) + ".DecomposerT(" + (x match {
        case x: XSet        => getDecomposerFor(x.elementType)      
        case x: XList       => getDecomposerFor(x.elementType)      
        case x: XArray      => getDecomposerFor(x.elementType)      
        case x: XMap        => getDecomposerFor(x.keyType) + ", " + getDecomposerFor(x.valueType)
        case x: XTuple      => x.types.map(x => getDecomposerFor(x)).mkString(", ")
        case x: XOptional   => getDecomposerFor(x.optionalType)
      }) + ")"

      case x: XDefinitionRef => database.resolve(x) match {
        case t : XMultitype => 
          var classname = x.namespace + "." + getTypeHintFor(x)
          
          classname + "Extensions.DecomposerT(" + (if (t.isInstanceOf[XUnion]) "" else classname) + ")"
        
        case _ => x.namespace + "." + getTypeHintFor(x) + ".DecomposerT()"
      }
    }
  }
  
  private def getExtractorFor(ref: XReference)(implicit database: XSchemaDatabase): String = {
    ref match {
      case x: XMap if (x.keyType == XString) => "haxe.data.collections.Map.StringKeyExtractorT(" + getExtractorFor(x.valueType) + ")"
      
      case x: XSet  => "haxe.data.collections.Set.ExtractorT("  + getExtractorFor(x.elementType) + ", " + getHasherFor(x.elementType) + ", " + getEqualFor(x.elementType) + ")"
      case x: XList => "haxe.data.collections.List.ExtractorT(" + getExtractorFor(x.elementType) + ", " + getEqualFor(x.elementType) + ")"
      case x: XMap  => "haxe.data.collections.Map.ExtractorT("  + getExtractorFor(x.keyType) + ", " + getExtractorFor(x.valueType) + ", " + 
                                                                  getHasherFor(x.keyType)    + ", " + getEqualFor(x.keyType) + ", " +
                                                                  getHasherFor(x.valueType)  + ", " + getEqualFor(x.valueType) + ")"

      case x: XPrimitiveRef  => getTypeHintFor(ref) + ".ExtractorT()"

      case x: XContainerRef => getTypeHintFor(ref) + ".ExtractorT(" + (x match {
        case x: XArray      => getExtractorFor(x.elementType)      
        case x: XTuple      => x.types.map(getExtractorFor _).mkString(", ")
        case x: XOptional   => getExtractorFor(x.optionalType)
        case _ => error("Impossible")
      }) + ")"

      case x: XDefinitionRef => database.resolve(x) match {
        case t : XMultitype => 
          var classname = x.namespace + "." + getTypeHintFor(x);
          
          classname + "Extensions.ExtractorT(" + (if (t.isInstanceOf[XUnion]) "" else classname) + ")"
        
        case _ => x.namespace + "." + getTypeHintFor(x) + ".ExtractorT()"
      }
    }
  }
  
  private def buildConstantsFor(namespace: String, code: CodeBuilder)(implicit database: XSchemaDatabase): Unit = {
    code.newline(2).add("class Constants ").block {    
      code.join(database.constantsIn(namespace), code.newline(2)) { constant =>
        buildDocumentationFor(constant.properties, code)
      
        code.add("public static var ${name}: ${type} = ${extractor}.extract(${json});",
          "name"      -> constant.name,
          "json"      -> renderHaXe(constant.default),
          "type"      -> typeSignatureOf(constant.constantType),
          "extractor" -> getExtractorFor(constant.constantType)
        )
      }
    }
  }
  
  private def renderHaXe(jvalue: JValue): String = {
    def escapeHaXeString(s: String): String = {
      val buf = new StringBuilder
      for (i <- 0 until s.length) {
        val c = s.charAt(i)
        buf.append(c match {
          case '"'  => "\\\""
          case '\\' => "\\\\"
          case '\b' => "\\b"
          case '\f' => "\\f"
          case '\n' => "\\n"
          case '\r' => "\\r"
          case '\t' => "\\t"
          case c if ((c >= '\u0000' && c < '\u001f') || (c >= '\u0080' && c < '\u00a0') || (c >= '\u2000' && c < '\u2100')) => "\\u%04x".format(c: Int)
          case c => c
        })
      }
      buf.toString
    }
    
    jvalue match {
      case JNothing     => "JNull"
      case JNull        => "JNull"
      case JString(v)   => "JString('" + escapeHaXeString(v) + "')"
      case JBool(v)     => "JBool(" + v + ")"
      case JInt(v)      => "JNumber(" + v + ")"
      case JDouble(v)   => "JNumber(" + v + ")"
      case JArray(v)    => "JArray([" + v.map(renderHaXe).mkString(", ") + "])"
      case JObject(v)   => "JObject([" + v.map(renderHaXe).mkString(", ") + "])"
      case JField(k, v) => "JField('" + escapeHaXeString(k) + "', " + renderHaXe(v) + ")"
    }
  }
  
  private def fieldNameOf(name: String) = {
    val haXeKeywords = "default, case, function, callback, return, break, continue, typedef, package, class, interface, public, private, static, new, null, import, using, switch, if, else, while, for, in, var"
    
    haXeKeywords.split("\\s*,\\s*").toList.find(_ == name).map(_ + "Value").getOrElse(name)
  }
  
  private def typeSignatureOf(x: XReference)(implicit database: XSchemaDatabase): String = walk(x, CodeBuilder.empty, typeSignatureWalker(database)).code
  
  private def typeSignatureWalker(implicit database: XSchemaDatabase) = new XSchemaWalker[CodeBuilder] {
    override def begin(data: CodeBuilder, opt: XOptional) = {
      data += "Option<"
    }
    
    override def begin(data: CodeBuilder, col: XCollection) = {
      data += ((col match {
        case x: XSet   => "haxe.data.collections.Set"
        case x: XArray => "Array"
        case x: XList  => "haxe.data.collections.List"
      }) + "<")
    }
    
    override def begin(data: CodeBuilder, map: XMap) = {
      data += "haxe.data.collections.Map<"
    }
    
    override def begin(data: CodeBuilder, tuple: XTuple) = {
      data += "Tuple" + tuple.types.length + "<"
    }
    
    override def separator(data: CodeBuilder) = data.add(", ")
    
    override def walk(data: CodeBuilder, prim: XPrimitiveRef) = {
      data += (prim match {
        case XString  => "String"
        case XInt     => "Int"
        case XLong    => "Int"
        case XFloat   => "Float"
        case XDouble  => "Float"
        case XBoolean => "Bool"
        case XJSON    => "haxe.text.json.JValue"
        case XDate    => "Date"
      })
    }
    
    override def walk(data: CodeBuilder, defn: XDefinitionRef) = {
      data += defn.namespace + "." + defn.name
    }
    
    override def end(data: CodeBuilder, opt: XOptional) = {
      data += ">"
    }
    
    override def end(data: CodeBuilder, col: XCollection) = {
      data += ">"
    }
    
    override def end(data: CodeBuilder, map: XMap) = {
      data += ">"
    }
    
    override def end(data: CodeBuilder, tuple: XTuple) = {
      data += ">"
    }
  }
}
