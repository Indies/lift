// This code was auto-generated by Lift Json XSchema - do not edit
package net.liftweb.json.xschema {
  import net.liftweb.json.JsonParser._
  import net.liftweb.json.JsonAST._
  import net.liftweb.json.xschema.DefaultOrderings._
  
  
  trait Orderings {
    implicit def XSchemaToOrderedXSchema(inner: XSchema) = OrderedXSchema(inner)
    implicit def XReferenceToOrderedXReference(inner: XReference) = OrderedXReference(inner)
    implicit def XPrimitiveRefToOrderedXPrimitiveRef(inner: XPrimitiveRef) = OrderedXPrimitiveRef(inner)
    implicit def XContainerRefToOrderedXContainerRef(inner: XContainerRef) = OrderedXContainerRef(inner)
    implicit def XCollectionToOrderedXCollection(inner: XCollection) = OrderedXCollection(inner)
    implicit def XDefinitionToOrderedXDefinition(inner: XDefinition) = OrderedXDefinition(inner)
    implicit def XMultitypeToOrderedXMultitype(inner: XMultitype) = OrderedXMultitype(inner)
    implicit def XFieldToOrderedXField(inner: XField) = OrderedXField(inner)
    implicit def XOrderToOrderedXOrder(inner: XOrder) = OrderedXOrder(inner)
    
    case class OrderedXSchema(inner: net.liftweb.json.xschema.XSchema) extends Ordered[net.liftweb.json.xschema.XSchema] {
      def compare(that: net.liftweb.json.xschema.XSchema): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XDefinition => that match {
            case y: net.liftweb.json.xschema.XDefinition => x.compare(y)
            case y: net.liftweb.json.xschema.XReference => -1
            case y: net.liftweb.json.xschema.XField => -1
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XReference => that match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => x.compare(y)
            case y: net.liftweb.json.xschema.XField => -1
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XField => that match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => 1
            case y: net.liftweb.json.xschema.XField => x.compare(y)
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XConstant => that match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => 1
            case y: net.liftweb.json.xschema.XField => 1
            case y: net.liftweb.json.xschema.XConstant => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXReference(inner: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XReference] {
      def compare(that: net.liftweb.json.xschema.XReference): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XPrimitiveRef => that match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => x.compare(y)
            case y: net.liftweb.json.xschema.XContainerRef => -1
            case y: net.liftweb.json.xschema.XDefinitionRef => -1
          }
          case x: net.liftweb.json.xschema.XContainerRef => that match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => 1
            case y: net.liftweb.json.xschema.XContainerRef => x.compare(y)
            case y: net.liftweb.json.xschema.XDefinitionRef => -1
          }
          case x: net.liftweb.json.xschema.XDefinitionRef => that match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => 1
            case y: net.liftweb.json.xschema.XContainerRef => 1
            case y: net.liftweb.json.xschema.XDefinitionRef => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXPrimitiveRef(inner: net.liftweb.json.xschema.XPrimitiveRef) extends Ordered[net.liftweb.json.xschema.XPrimitiveRef] {
      def compare(that: net.liftweb.json.xschema.XPrimitiveRef): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XBoolean.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => x.compare(y)
            case y: net.liftweb.json.xschema.XInt.type => -1
            case y: net.liftweb.json.xschema.XLong.type => -1
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XInt.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => x.compare(y)
            case y: net.liftweb.json.xschema.XLong.type => -1
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XLong.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => x.compare(y)
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XFloat.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => x.compare(y)
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XDouble.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => x.compare(y)
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XString.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => 1
            case y: net.liftweb.json.xschema.XString.type => x.compare(y)
            case y: net.liftweb.json.xschema.XJSON.type => -1
          }
          case x: net.liftweb.json.xschema.XJSON.type => that match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => 1
            case y: net.liftweb.json.xschema.XString.type => 1
            case y: net.liftweb.json.xschema.XJSON.type => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXContainerRef(inner: net.liftweb.json.xschema.XContainerRef) extends Ordered[net.liftweb.json.xschema.XContainerRef] {
      def compare(that: net.liftweb.json.xschema.XContainerRef): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XCollection => that match {
            case y: net.liftweb.json.xschema.XCollection => x.compare(y)
            case y: net.liftweb.json.xschema.XMap => -1
            case y: net.liftweb.json.xschema.XOptional => -1
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XMap => that match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => x.compare(y)
            case y: net.liftweb.json.xschema.XOptional => -1
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XOptional => that match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => 1
            case y: net.liftweb.json.xschema.XOptional => x.compare(y)
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XTuple => that match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => 1
            case y: net.liftweb.json.xschema.XOptional => 1
            case y: net.liftweb.json.xschema.XTuple => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXCollection(inner: net.liftweb.json.xschema.XCollection) extends Ordered[net.liftweb.json.xschema.XCollection] {
      def compare(that: net.liftweb.json.xschema.XCollection): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XList => that match {
            case y: net.liftweb.json.xschema.XList => x.compare(y)
            case y: net.liftweb.json.xschema.XSet => -1
            case y: net.liftweb.json.xschema.XArray => -1
          }
          case x: net.liftweb.json.xschema.XSet => that match {
            case y: net.liftweb.json.xschema.XList => 1
            case y: net.liftweb.json.xschema.XSet => x.compare(y)
            case y: net.liftweb.json.xschema.XArray => -1
          }
          case x: net.liftweb.json.xschema.XArray => that match {
            case y: net.liftweb.json.xschema.XList => 1
            case y: net.liftweb.json.xschema.XSet => 1
            case y: net.liftweb.json.xschema.XArray => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXDefinition(inner: net.liftweb.json.xschema.XDefinition) extends Ordered[net.liftweb.json.xschema.XDefinition] {
      def compare(that: net.liftweb.json.xschema.XDefinition): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XProduct => that match {
            case y: net.liftweb.json.xschema.XProduct => x.compare(y)
            case y: net.liftweb.json.xschema.XMultitype => -1
          }
          case x: net.liftweb.json.xschema.XMultitype => that match {
            case y: net.liftweb.json.xschema.XProduct => 1
            case y: net.liftweb.json.xschema.XMultitype => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXMultitype(inner: net.liftweb.json.xschema.XMultitype) extends Ordered[net.liftweb.json.xschema.XMultitype] {
      def compare(that: net.liftweb.json.xschema.XMultitype): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XCoproduct => that match {
            case y: net.liftweb.json.xschema.XCoproduct => x.compare(y)
            case y: net.liftweb.json.xschema.XUnion => -1
          }
          case x: net.liftweb.json.xschema.XUnion => that match {
            case y: net.liftweb.json.xschema.XCoproduct => 1
            case y: net.liftweb.json.xschema.XUnion => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXField(inner: net.liftweb.json.xschema.XField) extends Ordered[net.liftweb.json.xschema.XField] {
      def compare(that: net.liftweb.json.xschema.XField): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XRealField => that match {
            case y: net.liftweb.json.xschema.XRealField => x.compare(y)
            case y: net.liftweb.json.xschema.XViewField => -1
            case y: net.liftweb.json.xschema.XConstantField => -1
          }
          case x: net.liftweb.json.xschema.XViewField => that match {
            case y: net.liftweb.json.xschema.XRealField => 1
            case y: net.liftweb.json.xschema.XViewField => x.compare(y)
            case y: net.liftweb.json.xschema.XConstantField => -1
          }
          case x: net.liftweb.json.xschema.XConstantField => that match {
            case y: net.liftweb.json.xschema.XRealField => 1
            case y: net.liftweb.json.xschema.XViewField => 1
            case y: net.liftweb.json.xschema.XConstantField => x.compare(y)
          }
        }
      }
    }
    
    case class OrderedXOrder(inner: net.liftweb.json.xschema.XOrder) extends Ordered[net.liftweb.json.xschema.XOrder] {
      def compare(that: net.liftweb.json.xschema.XOrder): Int = {
        if (inner == that) 0
        else inner match {
          case x: net.liftweb.json.xschema.XOrderAscending.type => that match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => x.compare(y)
            case y: net.liftweb.json.xschema.XOrderDescending.type => -1
            case y: net.liftweb.json.xschema.XOrderIgnore.type => -1
          }
          case x: net.liftweb.json.xschema.XOrderDescending.type => that match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => 1
            case y: net.liftweb.json.xschema.XOrderDescending.type => x.compare(y)
            case y: net.liftweb.json.xschema.XOrderIgnore.type => -1
          }
          case x: net.liftweb.json.xschema.XOrderIgnore.type => that match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => 1
            case y: net.liftweb.json.xschema.XOrderDescending.type => 1
            case y: net.liftweb.json.xschema.XOrderIgnore.type => x.compare(y)
          }
        }
      }
    }
  }
  object Orderings extends Orderings
  
  sealed trait XSchema extends Product {
    
  }
  object XSchema {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XSchema"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XDefinition"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XField"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XConstant"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XReference extends Product with net.liftweb.json.xschema.XSchema {
    
  }
  object XReference {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XPrimitiveRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XContainerRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XPrimitiveRef extends Product with net.liftweb.json.xschema.XReference {
    
  }
  object XPrimitiveRef {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XPrimitiveRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XBoolean"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XInt"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XLong"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XFloat"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XDouble"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XString"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XJSON"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XContainerRef extends Product with net.liftweb.json.xschema.XReference {
    
  }
  object XContainerRef {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XContainerRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XCollection"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XMap"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XOptional"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XTuple"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XCollection extends Product with net.liftweb.json.xschema.XContainerRef {
    def elementType: net.liftweb.json.xschema.XReference
  }
  object XCollection {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XCollection"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XList"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XSet"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XArray"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XDefinition extends Product with net.liftweb.json.xschema.XSchema {
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef
    def properties: Map[String, String]
    def namespace: String
    def name: String
  }
  object XDefinition {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XDefinition"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XProduct"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XMultitype"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XProduct",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XMultitype extends Product with net.liftweb.json.xschema.XDefinition {
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef
    def properties: Map[String, String]
    def namespace: String
    def name: String
    def default: net.liftweb.json.JsonAST.JValue
  }
  object XMultitype {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XMultitype"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XCoproduct"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XUnion"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XCoproduct",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XField extends Product with net.liftweb.json.xschema.XSchema {
    def properties: Map[String, String]
    def name: String
    def fieldType: net.liftweb.json.xschema.XReference
  }
  object XField {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XField"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XRealField"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XViewField"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XConstantField"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XRealField",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  sealed trait XOrder extends Product {
    
  }
  object XOrder {
    lazy val xschema: XCoproduct = net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(JObject(JField("XCoproduct",JObject(JField("name",JString("XOrder"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("name",JString("XOrderAscending"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XOrderDescending"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::JObject(JField("name",JString("XOrderIgnore"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil)::Nil))::JField("default",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil))
  }
  
  case class XRoot(definitions: List[net.liftweb.json.xschema.XDefinition], constants: List[net.liftweb.json.xschema.XConstant], properties: Map[String, String])extends Ordered[net.liftweb.json.xschema.XRoot] {
    def compare(that: net.liftweb.json.xschema.XRoot): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.definitions.compare(that.definitions)
      if (c != 0) return c * 1
      
      c = this.constants.compare(that.constants)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XRoot {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XRoot"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("definitions"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinition"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("constants"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XConstant"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XDefinitionRef(name: String, namespace: String)extends Ordered[net.liftweb.json.xschema.XDefinitionRef] with net.liftweb.json.xschema.XReference {
    def compare(that: net.liftweb.json.xschema.XDefinitionRef): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.namespace.compare(that.namespace)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XDefinitionRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("namespace"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case object XBoolean extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XBoolean"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XInt extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XInt"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XLong extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XLong"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XFloat extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XFloat"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XDouble extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XDouble"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XString extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XString"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XJSON extends net.liftweb.json.xschema.XPrimitiveRef {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XJSON"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case class XList(elementType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XList] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XList): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.elementType.compare(that.elementType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XList {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XList"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("elementType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XSet(elementType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XSet] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XSet): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.elementType.compare(that.elementType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XSet {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XSet"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("elementType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XArray(elementType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XArray] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XArray): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.elementType.compare(that.elementType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XArray {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XArray"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("elementType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XMap(keyType: net.liftweb.json.xschema.XReference, valueType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XMap] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XMap): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.keyType.compare(that.keyType)
      if (c != 0) return c * 1
      
      c = this.valueType.compare(that.valueType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XMap {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XMap"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("keyType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("valueType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XOptional(optionalType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XOptional] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XOptional): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.optionalType.compare(that.optionalType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XOptional {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XOptional"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("optionalType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XTuple(types: List[net.liftweb.json.xschema.XReference])extends Ordered[net.liftweb.json.xschema.XTuple] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XTuple): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.types.compare(that.types)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XTuple {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XTuple"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("types"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  /** A product is analogous to a record: it contains fields, which may be any
   * type, have default values, and have a user-defined ordering. Products are
   * the fundamental building blocks used to construct most data structures.
   */
  case class XProduct(name: String, namespace: String, properties: Map[String, String], terms: List[net.liftweb.json.xschema.XField])extends Ordered[net.liftweb.json.xschema.XProduct] with net.liftweb.json.xschema.XDefinition with net.liftweb.json.xschema.XProductBehavior {
    def compare(that: net.liftweb.json.xschema.XProduct): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.namespace.compare(that.namespace)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.terms.compare(that.terms)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  object XProduct {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XProduct"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(JArray(JString("scala.class.traits")::JString("net.liftweb.json.xschema.XProductBehavior")::Nil)::JArray(JString("xschema.doc")::JString("A product is analogous to a record: it contains fields, which may ben                              any type, have default values, and have a user-defined ordering.n                              Products are the fundamental building blocks used to construct most n                              data structures.")::Nil)::Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("namespace"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("terms"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XField"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XViewField",JObject(JField("name",JString("referenceTo"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  /** A coproduct is a data structure that can assume one of N other types.
   * These types must be either products, or other coproducts -- primitives are
   * not allowed because they cannot be mapped cleanly to most languages (see
   * unions for a disjoint structure that allows primitives). <p> Note that most
   * languages cannot handle coproducts of unions.
   */
  case class XCoproduct(name: String, namespace: String, properties: Map[String, String], terms: List[net.liftweb.json.xschema.XDefinitionRef], default: net.liftweb.json.JsonAST.JValue)extends Ordered[net.liftweb.json.xschema.XCoproduct] with net.liftweb.json.xschema.XMultitype {
    def compare(that: net.liftweb.json.xschema.XCoproduct): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.namespace.compare(that.namespace)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.terms.compare(that.terms)
      if (c != 0) return c * 1
      
      c = this.default.compare(that.default)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  object XCoproduct {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XCoproduct"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(JArray(JString("xschema.doc")::JString("A coproduct is a data structure that can assume one of N other types. n                              These types must be either products, or other coproducts -- primitivesn                              are not allowed because they cannot be mapped cleanly to most languagesn                              (see unions for a disjoint structure that allows primitives). <p>n                              Note that most languages cannot handle coproducts of unions.n                              ")::Nil)::Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("namespace"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("terms"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("default"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XJSON",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XViewField",JObject(JField("name",JString("referenceTo"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  /** A union is a C-style union of N types -- referred to as terms. Unlike
   * coproducts, unions have no effect on the type hierarchy of the specified
   * terms, and the terms may include primitive types, in addition to references
   * to products, coproducts, and other unions. Although unions have names and
   * namespaces, most languages do not have explicit support for union types,
   * and in such cases, no entity will be generated for them; they will be
   * translated into the supertype of all the terms. <p>Some code generators may
   * not be able to handle unions or coproducts that contain unions.
   */
  case class XUnion(name: String, namespace: String, properties: Map[String, String], terms: List[net.liftweb.json.xschema.XReference], default: net.liftweb.json.JsonAST.JValue)extends Ordered[net.liftweb.json.xschema.XUnion] with net.liftweb.json.xschema.XMultitype {
    def compare(that: net.liftweb.json.xschema.XUnion): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.namespace.compare(that.namespace)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.terms.compare(that.terms)
      if (c != 0) return c * 1
      
      c = this.default.compare(that.default)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  object XUnion {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XUnion"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(JArray(JString("xschema.doc")::JString("A union is a C-style union of N types -- referred to as terms. Unlike n                              coproducts, unions have no effect on the type hierarchy of the specified n                              terms, and the terms may include primitive types, in addition to referencesn                              to products, coproducts, and other unions. Although unions have names and n                              namespaces, most languages do not have explicit support for union types, n                              and in such cases, no entity will be generated for them; they will be n                              translated into the supertype of all the terms. <p>Some code generators n                              may not be able to handle unions or coproducts that contain unions.")::Nil)::Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("namespace"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("terms"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XList",JObject(JField("elementType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("default"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XJSON",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XViewField",JObject(JField("name",JString("referenceTo"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XConstant(name: String, namespace: String, properties: Map[String, String], constantType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue)extends Ordered[net.liftweb.json.xschema.XConstant] with net.liftweb.json.xschema.XSchema {
    def compare(that: net.liftweb.json.xschema.XConstant): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.namespace.compare(that.namespace)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.constantType.compare(that.constantType)
      if (c != 0) return c * 1
      
      c = this.default.compare(that.default)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  object XConstant {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XConstant"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("namespace"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("constantType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("default"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XJSON",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XViewField",JObject(JField("name",JString("referenceTo"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XDefinitionRef"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XRealField(name: String, properties: Map[String, String], fieldType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue, order: net.liftweb.json.xschema.XOrder)extends Ordered[net.liftweb.json.xschema.XRealField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XRealField): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.fieldType.compare(that.fieldType)
      if (c != 0) return c * 1
      
      c = this.default.compare(that.default)
      if (c != 0) return c * 1
      
      c = this.order.compare(that.order)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XRealField {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XRealField"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("fieldType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("default"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XJSON",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("order"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XOrder"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XViewField(name: String, properties: Map[String, String], fieldType: net.liftweb.json.xschema.XReference)extends Ordered[net.liftweb.json.xschema.XViewField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XViewField): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.fieldType.compare(that.fieldType)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XViewField {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XViewField"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("fieldType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case class XConstantField(name: String, properties: Map[String, String], fieldType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue)extends Ordered[net.liftweb.json.xschema.XConstantField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XConstantField): Int = {
      import Orderings._
      
      if (this == that) return 0
      
      var c: Int = 0
      
      c = this.name.compare(that.name)
      if (c != 0) return c * 1
      
      c = this.properties.compare(that.properties)
      if (c != 0) return c * 1
      
      c = this.fieldType.compare(that.fieldType)
      if (c != 0) return c * 1
      
      c = this.default.compare(that.default)
      if (c != 0) return c * 1
      
      return this.hashCode - that.hashCode
    }
    
  }
  object XConstantField {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XConstantField"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(JObject(JField("XRealField",JObject(JField("name",JString("name"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XString",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("properties"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XMap",JObject(JField("keyType",JObject(JField("XString",JObject(Nil))::Nil))::JField("valueType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil))::JField("default",JArray(Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("fieldType"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XDefinitionRef",JObject(JField("name",JString("XReference"))::JField("namespace",JString("net.liftweb.json.xschema"))::Nil))::Nil))::JField("default",JObject(JField("XString",JObject(Nil))::Nil))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::JObject(JField("XRealField",JObject(JField("name",JString("default"))::JField("properties",JArray(Nil))::JField("fieldType",JObject(JField("XJSON",JObject(Nil))::Nil))::JField("default",JString(""))::JField("order",JObject(JField("XOrderAscending",JObject(Nil))::Nil))::Nil))::Nil)::Nil))::Nil))::Nil))
  }
  
  case object XOrderAscending extends net.liftweb.json.xschema.XOrder {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XOrderAscending"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XOrderDescending extends net.liftweb.json.xschema.XOrder {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XOrderDescending"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  case object XOrderIgnore extends net.liftweb.json.xschema.XOrder {
    lazy val xschema: XProduct = net.liftweb.json.xschema.Extractors.XProductExtractor.extract(JObject(JField("XProduct",JObject(JField("name",JString("XOrderIgnore"))::JField("namespace",JString("net.liftweb.json.xschema"))::JField("properties",JArray(Nil))::JField("terms",JArray(Nil))::Nil))::Nil))
  }
  
  trait Extractors {
    protected def extractField[T](jvalue: JValue, name: String, default: JValue, e: Extractor[T]): T = {
      try {
        e.extract((jvalue \ name -->? classOf[JField]).map(_.value).getOrElse(default))
      }
      catch {
        case _ => e.extract(default)
      }
    }
    
    implicit val XRootExtractor: Extractor[net.liftweb.json.xschema.XRoot] = new Extractor[net.liftweb.json.xschema.XRoot] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XRoot = {
        XRoot(
          extractField[List[net.liftweb.json.xschema.XDefinition]](jvalue, "definitions", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XDefinitionExtractor)),
          extractField[List[net.liftweb.json.xschema.XConstant]](jvalue, "constants", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XConstantExtractor)),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor))
        )
      }
    }
    
    private lazy val XSchemaExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XSchema] = ({
      case JField("XDefinition", value) => net.liftweb.json.xschema.Extractors.XDefinitionExtractor.extract(value)
      case JField("XReference", value) => net.liftweb.json.xschema.Extractors.XReferenceExtractor.extract(value)
      case JField("XField", value) => net.liftweb.json.xschema.Extractors.XFieldExtractor.extract(value)
      case JField("XConstant", value) => net.liftweb.json.xschema.Extractors.XConstantExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XSchema]).orElse(net.liftweb.json.xschema.Extractors.XDefinitionExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XReferenceExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XFieldExtractorFunction)
    implicit val XSchemaExtractor: Extractor[net.liftweb.json.xschema.XSchema] = new Extractor[net.liftweb.json.xschema.XSchema] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XSchema = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XSchema] = {
          (jvalue --> classOf[JObject]).obj.filter(XSchemaExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XSchemaExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XSchema, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    private lazy val XReferenceExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XReference] = ({
      case JField("XPrimitiveRef", value) => net.liftweb.json.xschema.Extractors.XPrimitiveRefExtractor.extract(value)
      case JField("XContainerRef", value) => net.liftweb.json.xschema.Extractors.XContainerRefExtractor.extract(value)
      case JField("XDefinitionRef", value) => net.liftweb.json.xschema.Extractors.XDefinitionRefExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XReference]).orElse(net.liftweb.json.xschema.Extractors.XPrimitiveRefExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XContainerRefExtractorFunction)
    implicit val XReferenceExtractor: Extractor[net.liftweb.json.xschema.XReference] = new Extractor[net.liftweb.json.xschema.XReference] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XReference = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XReference] = {
          (jvalue --> classOf[JObject]).obj.filter(XReferenceExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XReferenceExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XReference, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    private lazy val XPrimitiveRefExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XPrimitiveRef] = ({
      case JField("XBoolean", value) => net.liftweb.json.xschema.Extractors.XBooleanExtractor.extract(value)
      case JField("XInt", value) => net.liftweb.json.xschema.Extractors.XIntExtractor.extract(value)
      case JField("XLong", value) => net.liftweb.json.xschema.Extractors.XLongExtractor.extract(value)
      case JField("XFloat", value) => net.liftweb.json.xschema.Extractors.XFloatExtractor.extract(value)
      case JField("XDouble", value) => net.liftweb.json.xschema.Extractors.XDoubleExtractor.extract(value)
      case JField("XString", value) => net.liftweb.json.xschema.Extractors.XStringExtractor.extract(value)
      case JField("XJSON", value) => net.liftweb.json.xschema.Extractors.XJSONExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XPrimitiveRef])
    implicit val XPrimitiveRefExtractor: Extractor[net.liftweb.json.xschema.XPrimitiveRef] = new Extractor[net.liftweb.json.xschema.XPrimitiveRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XPrimitiveRef = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XPrimitiveRef] = {
          (jvalue --> classOf[JObject]).obj.filter(XPrimitiveRefExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XPrimitiveRefExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XPrimitiveRef, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    private lazy val XContainerRefExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XContainerRef] = ({
      case JField("XCollection", value) => net.liftweb.json.xschema.Extractors.XCollectionExtractor.extract(value)
      case JField("XMap", value) => net.liftweb.json.xschema.Extractors.XMapExtractor.extract(value)
      case JField("XOptional", value) => net.liftweb.json.xschema.Extractors.XOptionalExtractor.extract(value)
      case JField("XTuple", value) => net.liftweb.json.xschema.Extractors.XTupleExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XContainerRef]).orElse(net.liftweb.json.xschema.Extractors.XCollectionExtractorFunction)
    implicit val XContainerRefExtractor: Extractor[net.liftweb.json.xschema.XContainerRef] = new Extractor[net.liftweb.json.xschema.XContainerRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XContainerRef = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XContainerRef] = {
          (jvalue --> classOf[JObject]).obj.filter(XContainerRefExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XContainerRefExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XContainerRef, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XDefinitionRefExtractor: Extractor[net.liftweb.json.xschema.XDefinitionRef] = new Extractor[net.liftweb.json.xschema.XDefinitionRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDefinitionRef = {
        XDefinitionRef(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor)
        )
      }
    }
    
    implicit val XBooleanExtractor: Extractor[net.liftweb.json.xschema.XBoolean.type] = new Extractor[net.liftweb.json.xschema.XBoolean.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XBoolean.type = {
        XBoolean
      }
    }
    
    implicit val XIntExtractor: Extractor[net.liftweb.json.xschema.XInt.type] = new Extractor[net.liftweb.json.xschema.XInt.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XInt.type = {
        XInt
      }
    }
    
    implicit val XLongExtractor: Extractor[net.liftweb.json.xschema.XLong.type] = new Extractor[net.liftweb.json.xschema.XLong.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XLong.type = {
        XLong
      }
    }
    
    implicit val XFloatExtractor: Extractor[net.liftweb.json.xschema.XFloat.type] = new Extractor[net.liftweb.json.xschema.XFloat.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XFloat.type = {
        XFloat
      }
    }
    
    implicit val XDoubleExtractor: Extractor[net.liftweb.json.xschema.XDouble.type] = new Extractor[net.liftweb.json.xschema.XDouble.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDouble.type = {
        XDouble
      }
    }
    
    implicit val XStringExtractor: Extractor[net.liftweb.json.xschema.XString.type] = new Extractor[net.liftweb.json.xschema.XString.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XString.type = {
        XString
      }
    }
    
    implicit val XJSONExtractor: Extractor[net.liftweb.json.xschema.XJSON.type] = new Extractor[net.liftweb.json.xschema.XJSON.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XJSON.type = {
        XJSON
      }
    }
    
    private lazy val XCollectionExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XCollection] = ({
      case JField("XList", value) => net.liftweb.json.xschema.Extractors.XListExtractor.extract(value)
      case JField("XSet", value) => net.liftweb.json.xschema.Extractors.XSetExtractor.extract(value)
      case JField("XArray", value) => net.liftweb.json.xschema.Extractors.XArrayExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XCollection])
    implicit val XCollectionExtractor: Extractor[net.liftweb.json.xschema.XCollection] = new Extractor[net.liftweb.json.xschema.XCollection] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XCollection = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XCollection] = {
          (jvalue --> classOf[JObject]).obj.filter(XCollectionExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XCollectionExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XCollection, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XListExtractor: Extractor[net.liftweb.json.xschema.XList] = new Extractor[net.liftweb.json.xschema.XList] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XList = {
        XList(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XSetExtractor: Extractor[net.liftweb.json.xschema.XSet] = new Extractor[net.liftweb.json.xschema.XSet] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XSet = {
        XSet(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XArrayExtractor: Extractor[net.liftweb.json.xschema.XArray] = new Extractor[net.liftweb.json.xschema.XArray] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XArray = {
        XArray(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XMapExtractor: Extractor[net.liftweb.json.xschema.XMap] = new Extractor[net.liftweb.json.xschema.XMap] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XMap = {
        XMap(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "keyType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "valueType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XOptionalExtractor: Extractor[net.liftweb.json.xschema.XOptional] = new Extractor[net.liftweb.json.xschema.XOptional] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOptional = {
        XOptional(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "optionalType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XTupleExtractor: Extractor[net.liftweb.json.xschema.XTuple] = new Extractor[net.liftweb.json.xschema.XTuple] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XTuple = {
        XTuple(
          extractField[List[net.liftweb.json.xschema.XReference]](jvalue, "types", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XReferenceExtractor))
        )
      }
    }
    
    private lazy val XDefinitionExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XDefinition] = ({
      case JField("XProduct", value) => net.liftweb.json.xschema.Extractors.XProductExtractor.extract(value)
      case JField("XMultitype", value) => net.liftweb.json.xschema.Extractors.XMultitypeExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XDefinition]).orElse(net.liftweb.json.xschema.Extractors.XMultitypeExtractorFunction)
    implicit val XDefinitionExtractor: Extractor[net.liftweb.json.xschema.XDefinition] = new Extractor[net.liftweb.json.xschema.XDefinition] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDefinition = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XDefinition] = {
          (jvalue --> classOf[JObject]).obj.filter(XDefinitionExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XDefinitionExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XProduct",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XDefinition, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    private lazy val XMultitypeExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XMultitype] = ({
      case JField("XCoproduct", value) => net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(value)
      case JField("XUnion", value) => net.liftweb.json.xschema.Extractors.XUnionExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XMultitype])
    implicit val XMultitypeExtractor: Extractor[net.liftweb.json.xschema.XMultitype] = new Extractor[net.liftweb.json.xschema.XMultitype] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XMultitype = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XMultitype] = {
          (jvalue --> classOf[JObject]).obj.filter(XMultitypeExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XMultitypeExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XCoproduct",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XMultitype, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    private lazy val XFieldExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XField] = ({
      case JField("XRealField", value) => net.liftweb.json.xschema.Extractors.XRealFieldExtractor.extract(value)
      case JField("XViewField", value) => net.liftweb.json.xschema.Extractors.XViewFieldExtractor.extract(value)
      case JField("XConstantField", value) => net.liftweb.json.xschema.Extractors.XConstantFieldExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XField])
    implicit val XFieldExtractor: Extractor[net.liftweb.json.xschema.XField] = new Extractor[net.liftweb.json.xschema.XField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XField = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XField] = {
          (jvalue --> classOf[JObject]).obj.filter(XFieldExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XFieldExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XRealField",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XField, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XProductExtractor: Extractor[net.liftweb.json.xschema.XProduct] = new Extractor[net.liftweb.json.xschema.XProduct] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XProduct = {
        XProduct(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[List[net.liftweb.json.xschema.XField]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XFieldExtractor))
        )
      }
    }
    
    implicit val XCoproductExtractor: Extractor[net.liftweb.json.xschema.XCoproduct] = new Extractor[net.liftweb.json.xschema.XCoproduct] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XCoproduct = {
        XCoproduct(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[List[net.liftweb.json.xschema.XDefinitionRef]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XDefinitionRefExtractor)),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XUnionExtractor: Extractor[net.liftweb.json.xschema.XUnion] = new Extractor[net.liftweb.json.xschema.XUnion] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XUnion = {
        XUnion(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[List[net.liftweb.json.xschema.XReference]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XReferenceExtractor)),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XConstantExtractor: Extractor[net.liftweb.json.xschema.XConstant] = new Extractor[net.liftweb.json.xschema.XConstant] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XConstant = {
        XConstant(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "constantType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XRealFieldExtractor: Extractor[net.liftweb.json.xschema.XRealField] = new Extractor[net.liftweb.json.xschema.XRealField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XRealField = {
        XRealField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor),
          extractField[net.liftweb.json.xschema.XOrder](jvalue, "order", JObject(JField("XOrderAscending",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XOrderExtractor)
        )
      }
    }
    
    implicit val XViewFieldExtractor: Extractor[net.liftweb.json.xschema.XViewField] = new Extractor[net.liftweb.json.xschema.XViewField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XViewField = {
        XViewField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XConstantFieldExtractor: Extractor[net.liftweb.json.xschema.XConstantField] = new Extractor[net.liftweb.json.xschema.XConstantField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XConstantField = {
        XConstantField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, String]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.StringExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    private lazy val XOrderExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XOrder] = ({
      case JField("XOrderAscending", value) => net.liftweb.json.xschema.Extractors.XOrderAscendingExtractor.extract(value)
      case JField("XOrderDescending", value) => net.liftweb.json.xschema.Extractors.XOrderDescendingExtractor.extract(value)
      case JField("XOrderIgnore", value) => net.liftweb.json.xschema.Extractors.XOrderIgnoreExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XOrder])
    implicit val XOrderExtractor: Extractor[net.liftweb.json.xschema.XOrder] = new Extractor[net.liftweb.json.xschema.XOrder] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrder = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XOrder] = {
          (jvalue --> classOf[JObject]).obj.filter(XOrderExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XOrderExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XOrderAscending",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XOrder, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XOrderAscendingExtractor: Extractor[net.liftweb.json.xschema.XOrderAscending.type] = new Extractor[net.liftweb.json.xschema.XOrderAscending.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderAscending.type = {
        XOrderAscending
      }
    }
    
    implicit val XOrderDescendingExtractor: Extractor[net.liftweb.json.xschema.XOrderDescending.type] = new Extractor[net.liftweb.json.xschema.XOrderDescending.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderDescending.type = {
        XOrderDescending
      }
    }
    
    implicit val XOrderIgnoreExtractor: Extractor[net.liftweb.json.xschema.XOrderIgnore.type] = new Extractor[net.liftweb.json.xschema.XOrderIgnore.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderIgnore.type = {
        XOrderIgnore
      }
    }
  }
  object Extractors extends Extractors
  
  trait Decomposers {
    implicit val XRootDecomposer: Decomposer[net.liftweb.json.xschema.XRoot] = new Decomposer[net.liftweb.json.xschema.XRoot] {
      def decompose(tvalue: net.liftweb.json.xschema.XRoot): JValue = {
        JObject(
          JField("definitions", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XDefinitionDecomposer).decompose(tvalue.definitions)) ::
          JField("constants", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XConstantDecomposer).decompose(tvalue.constants)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) :: Nil
        )
      }
    }
    
    implicit val XSchemaDecomposer: Decomposer[net.liftweb.json.xschema.XSchema] = new Decomposer[net.liftweb.json.xschema.XSchema] {
      def decompose(tvalue: net.liftweb.json.xschema.XSchema): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XProduct => JObject(JField("XProduct", net.liftweb.json.xschema.Decomposers.XProductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDefinitionRef => JObject(JField("XDefinitionRef", net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XRealField => JObject(JField("XRealField", net.liftweb.json.xschema.Decomposers.XRealFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XViewField => JObject(JField("XViewField", net.liftweb.json.xschema.Decomposers.XViewFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstantField => JObject(JField("XConstantField", net.liftweb.json.xschema.Decomposers.XConstantFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstant => JObject(JField("XConstant", net.liftweb.json.xschema.Decomposers.XConstantDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XReferenceDecomposer: Decomposer[net.liftweb.json.xschema.XReference] = new Decomposer[net.liftweb.json.xschema.XReference] {
      def decompose(tvalue: net.liftweb.json.xschema.XReference): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDefinitionRef => JObject(JField("XDefinitionRef", net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XPrimitiveRefDecomposer: Decomposer[net.liftweb.json.xschema.XPrimitiveRef] = new Decomposer[net.liftweb.json.xschema.XPrimitiveRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XPrimitiveRef): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XContainerRefDecomposer: Decomposer[net.liftweb.json.xschema.XContainerRef] = new Decomposer[net.liftweb.json.xschema.XContainerRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XContainerRef): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XDefinitionRefDecomposer: Decomposer[net.liftweb.json.xschema.XDefinitionRef] = new Decomposer[net.liftweb.json.xschema.XDefinitionRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XDefinitionRef): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) :: Nil
        )
      }
    }
    
    implicit val XBooleanDecomposer: Decomposer[net.liftweb.json.xschema.XBoolean.type] = new Decomposer[net.liftweb.json.xschema.XBoolean.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XBoolean.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XIntDecomposer: Decomposer[net.liftweb.json.xschema.XInt.type] = new Decomposer[net.liftweb.json.xschema.XInt.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XInt.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XLongDecomposer: Decomposer[net.liftweb.json.xschema.XLong.type] = new Decomposer[net.liftweb.json.xschema.XLong.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XLong.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XFloatDecomposer: Decomposer[net.liftweb.json.xschema.XFloat.type] = new Decomposer[net.liftweb.json.xschema.XFloat.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XFloat.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XDoubleDecomposer: Decomposer[net.liftweb.json.xschema.XDouble.type] = new Decomposer[net.liftweb.json.xschema.XDouble.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XDouble.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XStringDecomposer: Decomposer[net.liftweb.json.xschema.XString.type] = new Decomposer[net.liftweb.json.xschema.XString.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XString.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XJSONDecomposer: Decomposer[net.liftweb.json.xschema.XJSON.type] = new Decomposer[net.liftweb.json.xschema.XJSON.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XJSON.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XCollectionDecomposer: Decomposer[net.liftweb.json.xschema.XCollection] = new Decomposer[net.liftweb.json.xschema.XCollection] {
      def decompose(tvalue: net.liftweb.json.xschema.XCollection): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XListDecomposer: Decomposer[net.liftweb.json.xschema.XList] = new Decomposer[net.liftweb.json.xschema.XList] {
      def decompose(tvalue: net.liftweb.json.xschema.XList): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XSetDecomposer: Decomposer[net.liftweb.json.xschema.XSet] = new Decomposer[net.liftweb.json.xschema.XSet] {
      def decompose(tvalue: net.liftweb.json.xschema.XSet): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XArrayDecomposer: Decomposer[net.liftweb.json.xschema.XArray] = new Decomposer[net.liftweb.json.xschema.XArray] {
      def decompose(tvalue: net.liftweb.json.xschema.XArray): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XMapDecomposer: Decomposer[net.liftweb.json.xschema.XMap] = new Decomposer[net.liftweb.json.xschema.XMap] {
      def decompose(tvalue: net.liftweb.json.xschema.XMap): JValue = {
        JObject(
          JField("keyType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.keyType)) ::
          JField("valueType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.valueType)) :: Nil
        )
      }
    }
    
    implicit val XOptionalDecomposer: Decomposer[net.liftweb.json.xschema.XOptional] = new Decomposer[net.liftweb.json.xschema.XOptional] {
      def decompose(tvalue: net.liftweb.json.xschema.XOptional): JValue = {
        JObject(
          JField("optionalType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.optionalType)) :: Nil
        )
      }
    }
    
    implicit val XTupleDecomposer: Decomposer[net.liftweb.json.xschema.XTuple] = new Decomposer[net.liftweb.json.xschema.XTuple] {
      def decompose(tvalue: net.liftweb.json.xschema.XTuple): JValue = {
        JObject(
          JField("types", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XReferenceDecomposer).decompose(tvalue.types)) :: Nil
        )
      }
    }
    
    implicit val XDefinitionDecomposer: Decomposer[net.liftweb.json.xschema.XDefinition] = new Decomposer[net.liftweb.json.xschema.XDefinition] {
      def decompose(tvalue: net.liftweb.json.xschema.XDefinition): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XProduct => JObject(JField("XProduct", net.liftweb.json.xschema.Decomposers.XProductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XMultitypeDecomposer: Decomposer[net.liftweb.json.xschema.XMultitype] = new Decomposer[net.liftweb.json.xschema.XMultitype] {
      def decompose(tvalue: net.liftweb.json.xschema.XMultitype): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XFieldDecomposer: Decomposer[net.liftweb.json.xschema.XField] = new Decomposer[net.liftweb.json.xschema.XField] {
      def decompose(tvalue: net.liftweb.json.xschema.XField): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XRealField => JObject(JField("XRealField", net.liftweb.json.xschema.Decomposers.XRealFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XViewField => JObject(JField("XViewField", net.liftweb.json.xschema.Decomposers.XViewFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstantField => JObject(JField("XConstantField", net.liftweb.json.xschema.Decomposers.XConstantFieldDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XProductDecomposer: Decomposer[net.liftweb.json.xschema.XProduct] = new Decomposer[net.liftweb.json.xschema.XProduct] {
      def decompose(tvalue: net.liftweb.json.xschema.XProduct): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XFieldDecomposer).decompose(tvalue.terms)) :: Nil
        )
      }
    }
    
    implicit val XCoproductDecomposer: Decomposer[net.liftweb.json.xschema.XCoproduct] = new Decomposer[net.liftweb.json.xschema.XCoproduct] {
      def decompose(tvalue: net.liftweb.json.xschema.XCoproduct): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer).decompose(tvalue.terms)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XUnionDecomposer: Decomposer[net.liftweb.json.xschema.XUnion] = new Decomposer[net.liftweb.json.xschema.XUnion] {
      def decompose(tvalue: net.liftweb.json.xschema.XUnion): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XReferenceDecomposer).decompose(tvalue.terms)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XConstantDecomposer: Decomposer[net.liftweb.json.xschema.XConstant] = new Decomposer[net.liftweb.json.xschema.XConstant] {
      def decompose(tvalue: net.liftweb.json.xschema.XConstant): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("constantType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.constantType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XRealFieldDecomposer: Decomposer[net.liftweb.json.xschema.XRealField] = new Decomposer[net.liftweb.json.xschema.XRealField] {
      def decompose(tvalue: net.liftweb.json.xschema.XRealField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) ::
          JField("order", net.liftweb.json.xschema.Decomposers.XOrderDecomposer.decompose(tvalue.order)) :: Nil
        )
      }
    }
    
    implicit val XViewFieldDecomposer: Decomposer[net.liftweb.json.xschema.XViewField] = new Decomposer[net.liftweb.json.xschema.XViewField] {
      def decompose(tvalue: net.liftweb.json.xschema.XViewField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) :: Nil
        )
      }
    }
    
    implicit val XConstantFieldDecomposer: Decomposer[net.liftweb.json.xschema.XConstantField] = new Decomposer[net.liftweb.json.xschema.XConstantField] {
      def decompose(tvalue: net.liftweb.json.xschema.XConstantField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XOrderDecomposer: Decomposer[net.liftweb.json.xschema.XOrder] = new Decomposer[net.liftweb.json.xschema.XOrder] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrder): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XOrderAscending.type => JObject(JField("XOrderAscending", net.liftweb.json.xschema.Decomposers.XOrderAscendingDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOrderDescending.type => JObject(JField("XOrderDescending", net.liftweb.json.xschema.Decomposers.XOrderDescendingDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOrderIgnore.type => JObject(JField("XOrderIgnore", net.liftweb.json.xschema.Decomposers.XOrderIgnoreDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XOrderAscendingDecomposer: Decomposer[net.liftweb.json.xschema.XOrderAscending.type] = new Decomposer[net.liftweb.json.xschema.XOrderAscending.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderAscending.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XOrderDescendingDecomposer: Decomposer[net.liftweb.json.xschema.XOrderDescending.type] = new Decomposer[net.liftweb.json.xschema.XOrderDescending.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderDescending.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XOrderIgnoreDecomposer: Decomposer[net.liftweb.json.xschema.XOrderIgnore.type] = new Decomposer[net.liftweb.json.xschema.XOrderIgnore.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderIgnore.type): JValue = {
        JObject(
           Nil
        )
      }
    }
  }
  object Decomposers extends Decomposers
  
  object Serialization extends Decomposers with Extractors with Orderings with SerializationImplicits {
    lazy val xschema: XRoot = net.liftweb.json.xschema.Extractors.XRootExtractor.extract(parse("""{"definitions":[{"XProduct":{"name":"XRoot","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"definitions","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XDefinition","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"constants","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XConstant","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}}]}},{"XCoproduct":{"name":"XSchema","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XDefinition","namespace":"net.liftweb.json.xschema"},{"name":"XReference","namespace":"net.liftweb.json.xschema"},{"name":"XField","namespace":"net.liftweb.json.xschema"},{"name":"XConstant","namespace":"net.liftweb.json.xschema"}],"default":{"XString":{}}}},{"XCoproduct":{"name":"XReference","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XPrimitiveRef","namespace":"net.liftweb.json.xschema"},{"name":"XContainerRef","namespace":"net.liftweb.json.xschema"},{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}],"default":{"XString":{}}}},{"XCoproduct":{"name":"XPrimitiveRef","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XBoolean","namespace":"net.liftweb.json.xschema"},{"name":"XInt","namespace":"net.liftweb.json.xschema"},{"name":"XLong","namespace":"net.liftweb.json.xschema"},{"name":"XFloat","namespace":"net.liftweb.json.xschema"},{"name":"XDouble","namespace":"net.liftweb.json.xschema"},{"name":"XString","namespace":"net.liftweb.json.xschema"},{"name":"XJSON","namespace":"net.liftweb.json.xschema"}],"default":{"XString":{}}}},{"XCoproduct":{"name":"XContainerRef","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XCollection","namespace":"net.liftweb.json.xschema"},{"name":"XMap","namespace":"net.liftweb.json.xschema"},{"name":"XOptional","namespace":"net.liftweb.json.xschema"},{"name":"XTuple","namespace":"net.liftweb.json.xschema"}],"default":{"XList":{"elementType":{"XString":{}}}}}},{"XProduct":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"namespace","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XBoolean","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XInt","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XLong","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XFloat","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XDouble","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XString","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XJSON","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XCoproduct":{"name":"XCollection","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XList","namespace":"net.liftweb.json.xschema"},{"name":"XSet","namespace":"net.liftweb.json.xschema"},{"name":"XArray","namespace":"net.liftweb.json.xschema"}],"default":{"XList":{"elementType":{"XString":{}}}}}},{"XProduct":{"name":"XList","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"elementType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XSet","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"elementType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XArray","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"elementType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XMap","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"keyType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"valueType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XOptional","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"optionalType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XTuple","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"types","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}}]}},{"XCoproduct":{"name":"XDefinition","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XProduct","namespace":"net.liftweb.json.xschema"},{"name":"XMultitype","namespace":"net.liftweb.json.xschema"}],"default":{"XProduct":{}}}},{"XCoproduct":{"name":"XMultitype","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XCoproduct","namespace":"net.liftweb.json.xschema"},{"name":"XUnion","namespace":"net.liftweb.json.xschema"}],"default":{"XCoproduct":{}}}},{"XCoproduct":{"name":"XField","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XRealField","namespace":"net.liftweb.json.xschema"},{"name":"XViewField","namespace":"net.liftweb.json.xschema"},{"name":"XConstantField","namespace":"net.liftweb.json.xschema"}],"default":{"XRealField":{}}}},{"XProduct":{"name":"XProduct","namespace":"net.liftweb.json.xschema","properties":[["scala.class.traits","net.liftweb.json.xschema.XProductBehavior"],["xschema.doc","A product is analogous to a record: it contains fields, which may be\n                              any type, have default values, and have a user-defined ordering.\n                              Products are the fundamental building blocks used to construct most \n                              data structures."]],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"namespace","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"terms","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XField","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XViewField":{"name":"referenceTo","properties":[],"fieldType":{"XDefinitionRef":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}}}}]}},{"XProduct":{"name":"XCoproduct","namespace":"net.liftweb.json.xschema","properties":[["xschema.doc","A coproduct is a data structure that can assume one of N other types. \n                              These types must be either products, or other coproducts -- primitives\n                              are not allowed because they cannot be mapped cleanly to most languages\n                              (see unions for a disjoint structure that allows primitives). <p>\n                              Note that most languages cannot handle coproducts of unions.\n                              "]],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"namespace","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"terms","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"default","properties":[],"fieldType":{"XJSON":{}},"default":"","order":{"XOrderAscending":{}}}},{"XViewField":{"name":"referenceTo","properties":[],"fieldType":{"XDefinitionRef":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}}}}]}},{"XProduct":{"name":"XUnion","namespace":"net.liftweb.json.xschema","properties":[["xschema.doc","A union is a C-style union of N types -- referred to as terms. Unlike \n                              coproducts, unions have no effect on the type hierarchy of the specified \n                              terms, and the terms may include primitive types, in addition to references\n                              to products, coproducts, and other unions. Although unions have names and \n                              namespaces, most languages do not have explicit support for union types, \n                              and in such cases, no entity will be generated for them; they will be \n                              translated into the supertype of all the terms. <p>Some code generators \n                              may not be able to handle unions or coproducts that contain unions."]],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"namespace","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"terms","properties":[],"fieldType":{"XList":{"elementType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"default","properties":[],"fieldType":{"XJSON":{}},"default":"","order":{"XOrderAscending":{}}}},{"XViewField":{"name":"referenceTo","properties":[],"fieldType":{"XDefinitionRef":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}}}}]}},{"XProduct":{"name":"XConstant","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"namespace","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"constantType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XString":{}},"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"default","properties":[],"fieldType":{"XJSON":{}},"default":"","order":{"XOrderAscending":{}}}},{"XViewField":{"name":"referenceTo","properties":[],"fieldType":{"XDefinitionRef":{"name":"XDefinitionRef","namespace":"net.liftweb.json.xschema"}}}}]}},{"XProduct":{"name":"XRealField","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"fieldType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XString":{}},"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"default","properties":[],"fieldType":{"XJSON":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"order","properties":[],"fieldType":{"XDefinitionRef":{"name":"XOrder","namespace":"net.liftweb.json.xschema"}},"default":{"XOrderAscending":{}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XViewField","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"fieldType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XDefinitionRef":{"name":"","namespace":""}},"order":{"XOrderAscending":{}}}}]}},{"XProduct":{"name":"XConstantField","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"XRealField":{"name":"name","properties":[],"fieldType":{"XString":{}},"default":"","order":{"XOrderAscending":{}}}},{"XRealField":{"name":"properties","properties":[],"fieldType":{"XMap":{"keyType":{"XString":{}},"valueType":{"XString":{}}}},"default":[],"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"fieldType","properties":[],"fieldType":{"XDefinitionRef":{"name":"XReference","namespace":"net.liftweb.json.xschema"}},"default":{"XString":{}},"order":{"XOrderAscending":{}}}},{"XRealField":{"name":"default","properties":[],"fieldType":{"XJSON":{}},"default":"","order":{"XOrderAscending":{}}}}]}},{"XCoproduct":{"name":"XOrder","namespace":"net.liftweb.json.xschema","properties":[],"terms":[{"name":"XOrderAscending","namespace":"net.liftweb.json.xschema"},{"name":"XOrderDescending","namespace":"net.liftweb.json.xschema"},{"name":"XOrderIgnore","namespace":"net.liftweb.json.xschema"}],"default":{"XOrderAscending":{}}}},{"XProduct":{"name":"XOrderAscending","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XOrderDescending","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}},{"XProduct":{"name":"XOrderIgnore","namespace":"net.liftweb.json.xschema","properties":[],"terms":[]}}],"constants":[],"properties":[]} """))
  }
  
  object Constants {
    import Serialization._
    
    
  }
}