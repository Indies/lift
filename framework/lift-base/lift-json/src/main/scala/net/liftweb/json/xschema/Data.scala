// This code was auto-generated by Lift Json XSchema - do not edit
package net.liftweb.json.xschema {
  import net.liftweb.json.JsonParser._
  import net.liftweb.json.JsonAST._
  import net.liftweb.json.xschema.DefaultOrderings._
  
  
  trait Orderings {
    implicit val XRootOrdering: Ordering[net.liftweb.json.xschema.XRoot] = new Ordering[net.liftweb.json.xschema.XRoot] {
      def compare(v1: net.liftweb.json.xschema.XRoot, v2: net.liftweb.json.xschema.XRoot): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XDefinitionOrdering).compare(v1.definitions, v2.definitions) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XConstantOrdering).compare(v1.constants, v2.constants) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, empty)))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XSchemaOrdering: Ordering[net.liftweb.json.xschema.XSchema] = new Ordering[net.liftweb.json.xschema.XSchema] {
      def compare(v1: net.liftweb.json.xschema.XSchema, v2: net.liftweb.json.xschema.XSchema): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XDefinition => v2 match {
            case y: net.liftweb.json.xschema.XDefinition => net.liftweb.json.xschema.Orderings.XDefinitionOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XReference => -1
            case y: net.liftweb.json.xschema.XField => -1
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XReference => v2 match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XField => -1
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XField => v2 match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => 1
            case y: net.liftweb.json.xschema.XField => net.liftweb.json.xschema.Orderings.XFieldOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XConstant => -1
          }
          case x: net.liftweb.json.xschema.XConstant => v2 match {
            case y: net.liftweb.json.xschema.XDefinition => 1
            case y: net.liftweb.json.xschema.XReference => 1
            case y: net.liftweb.json.xschema.XField => 1
            case y: net.liftweb.json.xschema.XConstant => net.liftweb.json.xschema.Orderings.XConstantOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXSchema(v1: net.liftweb.json.xschema.XSchema) extends Ordered[net.liftweb.json.xschema.XSchema] {
      def compare(v2: net.liftweb.json.xschema.XSchema): Int = XSchemaOrdering.compare(v1, v2)
    }
    implicit def XSchemaToOrderedXSchema(v: net.liftweb.json.xschema.XSchema) = OrderedXSchema(v)
    
    implicit val XReferenceOrdering: Ordering[net.liftweb.json.xschema.XReference] = new Ordering[net.liftweb.json.xschema.XReference] {
      def compare(v1: net.liftweb.json.xschema.XReference, v2: net.liftweb.json.xschema.XReference): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XPrimitiveRef => v2 match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => net.liftweb.json.xschema.Orderings.XPrimitiveRefOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XContainerRef => -1
            case y: net.liftweb.json.xschema.XDefinitionRef => -1
          }
          case x: net.liftweb.json.xschema.XContainerRef => v2 match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => 1
            case y: net.liftweb.json.xschema.XContainerRef => net.liftweb.json.xschema.Orderings.XContainerRefOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XDefinitionRef => -1
          }
          case x: net.liftweb.json.xschema.XDefinitionRef => v2 match {
            case y: net.liftweb.json.xschema.XPrimitiveRef => 1
            case y: net.liftweb.json.xschema.XContainerRef => 1
            case y: net.liftweb.json.xschema.XDefinitionRef => net.liftweb.json.xschema.Orderings.XDefinitionRefOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXReference(v1: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XReference] {
      def compare(v2: net.liftweb.json.xschema.XReference): Int = XReferenceOrdering.compare(v1, v2)
    }
    implicit def XReferenceToOrderedXReference(v: net.liftweb.json.xschema.XReference) = OrderedXReference(v)
    
    implicit val XPrimitiveRefOrdering: Ordering[net.liftweb.json.xschema.XPrimitiveRef] = new Ordering[net.liftweb.json.xschema.XPrimitiveRef] {
      def compare(v1: net.liftweb.json.xschema.XPrimitiveRef, v2: net.liftweb.json.xschema.XPrimitiveRef): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XBoolean.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => net.liftweb.json.xschema.Orderings.XBooleanOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XInt.type => -1
            case y: net.liftweb.json.xschema.XLong.type => -1
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XInt.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => net.liftweb.json.xschema.Orderings.XIntOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XLong.type => -1
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XLong.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => net.liftweb.json.xschema.Orderings.XLongOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XFloat.type => -1
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XFloat.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => net.liftweb.json.xschema.Orderings.XFloatOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XDouble.type => -1
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XDouble.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => net.liftweb.json.xschema.Orderings.XDoubleOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XString.type => -1
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XString.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => 1
            case y: net.liftweb.json.xschema.XString.type => net.liftweb.json.xschema.Orderings.XStringOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XJSON.type => -1
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XJSON.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => 1
            case y: net.liftweb.json.xschema.XString.type => 1
            case y: net.liftweb.json.xschema.XJSON.type => net.liftweb.json.xschema.Orderings.XJSONOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XDate.type => -1
          }
          case x: net.liftweb.json.xschema.XDate.type => v2 match {
            case y: net.liftweb.json.xschema.XBoolean.type => 1
            case y: net.liftweb.json.xschema.XInt.type => 1
            case y: net.liftweb.json.xschema.XLong.type => 1
            case y: net.liftweb.json.xschema.XFloat.type => 1
            case y: net.liftweb.json.xschema.XDouble.type => 1
            case y: net.liftweb.json.xschema.XString.type => 1
            case y: net.liftweb.json.xschema.XJSON.type => 1
            case y: net.liftweb.json.xschema.XDate.type => net.liftweb.json.xschema.Orderings.XDateOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXPrimitiveRef(v1: net.liftweb.json.xschema.XPrimitiveRef) extends Ordered[net.liftweb.json.xschema.XPrimitiveRef] {
      def compare(v2: net.liftweb.json.xschema.XPrimitiveRef): Int = XPrimitiveRefOrdering.compare(v1, v2)
    }
    implicit def XPrimitiveRefToOrderedXPrimitiveRef(v: net.liftweb.json.xschema.XPrimitiveRef) = OrderedXPrimitiveRef(v)
    
    implicit val XContainerRefOrdering: Ordering[net.liftweb.json.xschema.XContainerRef] = new Ordering[net.liftweb.json.xschema.XContainerRef] {
      def compare(v1: net.liftweb.json.xschema.XContainerRef, v2: net.liftweb.json.xschema.XContainerRef): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XCollection => v2 match {
            case y: net.liftweb.json.xschema.XCollection => net.liftweb.json.xschema.Orderings.XCollectionOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XMap => -1
            case y: net.liftweb.json.xschema.XOptional => -1
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XMap => v2 match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => net.liftweb.json.xschema.Orderings.XMapOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XOptional => -1
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XOptional => v2 match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => 1
            case y: net.liftweb.json.xschema.XOptional => net.liftweb.json.xschema.Orderings.XOptionalOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XTuple => -1
          }
          case x: net.liftweb.json.xschema.XTuple => v2 match {
            case y: net.liftweb.json.xschema.XCollection => 1
            case y: net.liftweb.json.xschema.XMap => 1
            case y: net.liftweb.json.xschema.XOptional => 1
            case y: net.liftweb.json.xschema.XTuple => net.liftweb.json.xschema.Orderings.XTupleOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXContainerRef(v1: net.liftweb.json.xschema.XContainerRef) extends Ordered[net.liftweb.json.xschema.XContainerRef] {
      def compare(v2: net.liftweb.json.xschema.XContainerRef): Int = XContainerRefOrdering.compare(v1, v2)
    }
    implicit def XContainerRefToOrderedXContainerRef(v: net.liftweb.json.xschema.XContainerRef) = OrderedXContainerRef(v)
    
    implicit val XDefinitionRefOrdering: Ordering[net.liftweb.json.xschema.XDefinitionRef] = new Ordering[net.liftweb.json.xschema.XDefinitionRef] {
      def compare(v1: net.liftweb.json.xschema.XDefinitionRef, v2: net.liftweb.json.xschema.XDefinitionRef): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.namespace, v2.namespace) * 1, empty))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XBooleanOrdering: Ordering[net.liftweb.json.xschema.XBoolean.type] = new Ordering[net.liftweb.json.xschema.XBoolean.type] {
      def compare(v1: net.liftweb.json.xschema.XBoolean.type, v2: net.liftweb.json.xschema.XBoolean.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XIntOrdering: Ordering[net.liftweb.json.xschema.XInt.type] = new Ordering[net.liftweb.json.xschema.XInt.type] {
      def compare(v1: net.liftweb.json.xschema.XInt.type, v2: net.liftweb.json.xschema.XInt.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XLongOrdering: Ordering[net.liftweb.json.xschema.XLong.type] = new Ordering[net.liftweb.json.xschema.XLong.type] {
      def compare(v1: net.liftweb.json.xschema.XLong.type, v2: net.liftweb.json.xschema.XLong.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XFloatOrdering: Ordering[net.liftweb.json.xschema.XFloat.type] = new Ordering[net.liftweb.json.xschema.XFloat.type] {
      def compare(v1: net.liftweb.json.xschema.XFloat.type, v2: net.liftweb.json.xschema.XFloat.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XDoubleOrdering: Ordering[net.liftweb.json.xschema.XDouble.type] = new Ordering[net.liftweb.json.xschema.XDouble.type] {
      def compare(v1: net.liftweb.json.xschema.XDouble.type, v2: net.liftweb.json.xschema.XDouble.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XStringOrdering: Ordering[net.liftweb.json.xschema.XString.type] = new Ordering[net.liftweb.json.xschema.XString.type] {
      def compare(v1: net.liftweb.json.xschema.XString.type, v2: net.liftweb.json.xschema.XString.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XJSONOrdering: Ordering[net.liftweb.json.xschema.XJSON.type] = new Ordering[net.liftweb.json.xschema.XJSON.type] {
      def compare(v1: net.liftweb.json.xschema.XJSON.type, v2: net.liftweb.json.xschema.XJSON.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XDateOrdering: Ordering[net.liftweb.json.xschema.XDate.type] = new Ordering[net.liftweb.json.xschema.XDate.type] {
      def compare(v1: net.liftweb.json.xschema.XDate.type, v2: net.liftweb.json.xschema.XDate.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XCollectionOrdering: Ordering[net.liftweb.json.xschema.XCollection] = new Ordering[net.liftweb.json.xschema.XCollection] {
      def compare(v1: net.liftweb.json.xschema.XCollection, v2: net.liftweb.json.xschema.XCollection): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XList => v2 match {
            case y: net.liftweb.json.xschema.XList => net.liftweb.json.xschema.Orderings.XListOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XSet => -1
            case y: net.liftweb.json.xschema.XArray => -1
          }
          case x: net.liftweb.json.xschema.XSet => v2 match {
            case y: net.liftweb.json.xschema.XList => 1
            case y: net.liftweb.json.xschema.XSet => net.liftweb.json.xschema.Orderings.XSetOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XArray => -1
          }
          case x: net.liftweb.json.xschema.XArray => v2 match {
            case y: net.liftweb.json.xschema.XList => 1
            case y: net.liftweb.json.xschema.XSet => 1
            case y: net.liftweb.json.xschema.XArray => net.liftweb.json.xschema.Orderings.XArrayOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXCollection(v1: net.liftweb.json.xschema.XCollection) extends Ordered[net.liftweb.json.xschema.XCollection] {
      def compare(v2: net.liftweb.json.xschema.XCollection): Int = XCollectionOrdering.compare(v1, v2)
    }
    implicit def XCollectionToOrderedXCollection(v: net.liftweb.json.xschema.XCollection) = OrderedXCollection(v)
    
    implicit val XListOrdering: Ordering[net.liftweb.json.xschema.XList] = new Ordering[net.liftweb.json.xschema.XList] {
      def compare(v1: net.liftweb.json.xschema.XList, v2: net.liftweb.json.xschema.XList): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.elementType, v2.elementType) * 1, empty)
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XSetOrdering: Ordering[net.liftweb.json.xschema.XSet] = new Ordering[net.liftweb.json.xschema.XSet] {
      def compare(v1: net.liftweb.json.xschema.XSet, v2: net.liftweb.json.xschema.XSet): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.elementType, v2.elementType) * 1, empty)
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XArrayOrdering: Ordering[net.liftweb.json.xschema.XArray] = new Ordering[net.liftweb.json.xschema.XArray] {
      def compare(v1: net.liftweb.json.xschema.XArray, v2: net.liftweb.json.xschema.XArray): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.elementType, v2.elementType) * 1, empty)
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XMapOrdering: Ordering[net.liftweb.json.xschema.XMap] = new Ordering[net.liftweb.json.xschema.XMap] {
      def compare(v1: net.liftweb.json.xschema.XMap, v2: net.liftweb.json.xschema.XMap): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.keyType, v2.keyType) * 1, cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.valueType, v2.valueType) * 1, empty))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XOptionalOrdering: Ordering[net.liftweb.json.xschema.XOptional] = new Ordering[net.liftweb.json.xschema.XOptional] {
      def compare(v1: net.liftweb.json.xschema.XOptional, v2: net.liftweb.json.xschema.XOptional): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.optionalType, v2.optionalType) * 1, empty)
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XTupleOrdering: Ordering[net.liftweb.json.xschema.XTuple] = new Ordering[net.liftweb.json.xschema.XTuple] {
      def compare(v1: net.liftweb.json.xschema.XTuple, v2: net.liftweb.json.xschema.XTuple): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XReferenceOrdering).compare(v1.types, v2.types) * 1, empty)
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XDefinitionOrdering: Ordering[net.liftweb.json.xschema.XDefinition] = new Ordering[net.liftweb.json.xschema.XDefinition] {
      def compare(v1: net.liftweb.json.xschema.XDefinition, v2: net.liftweb.json.xschema.XDefinition): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XProduct => v2 match {
            case y: net.liftweb.json.xschema.XProduct => net.liftweb.json.xschema.Orderings.XProductOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XMultitype => -1
          }
          case x: net.liftweb.json.xschema.XMultitype => v2 match {
            case y: net.liftweb.json.xschema.XProduct => 1
            case y: net.liftweb.json.xschema.XMultitype => net.liftweb.json.xschema.Orderings.XMultitypeOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXDefinition(v1: net.liftweb.json.xschema.XDefinition) extends Ordered[net.liftweb.json.xschema.XDefinition] {
      def compare(v2: net.liftweb.json.xschema.XDefinition): Int = XDefinitionOrdering.compare(v1, v2)
    }
    implicit def XDefinitionToOrderedXDefinition(v: net.liftweb.json.xschema.XDefinition) = OrderedXDefinition(v)
    
    implicit val XMultitypeOrdering: Ordering[net.liftweb.json.xschema.XMultitype] = new Ordering[net.liftweb.json.xschema.XMultitype] {
      def compare(v1: net.liftweb.json.xschema.XMultitype, v2: net.liftweb.json.xschema.XMultitype): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XCoproduct => v2 match {
            case y: net.liftweb.json.xschema.XCoproduct => net.liftweb.json.xschema.Orderings.XCoproductOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XUnion => -1
          }
          case x: net.liftweb.json.xschema.XUnion => v2 match {
            case y: net.liftweb.json.xschema.XCoproduct => 1
            case y: net.liftweb.json.xschema.XUnion => net.liftweb.json.xschema.Orderings.XUnionOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXMultitype(v1: net.liftweb.json.xschema.XMultitype) extends Ordered[net.liftweb.json.xschema.XMultitype] {
      def compare(v2: net.liftweb.json.xschema.XMultitype): Int = XMultitypeOrdering.compare(v1, v2)
    }
    implicit def XMultitypeToOrderedXMultitype(v: net.liftweb.json.xschema.XMultitype) = OrderedXMultitype(v)
    
    implicit val XFieldOrdering: Ordering[net.liftweb.json.xschema.XField] = new Ordering[net.liftweb.json.xschema.XField] {
      def compare(v1: net.liftweb.json.xschema.XField, v2: net.liftweb.json.xschema.XField): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XRealField => v2 match {
            case y: net.liftweb.json.xschema.XRealField => net.liftweb.json.xschema.Orderings.XRealFieldOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XViewField => -1
            case y: net.liftweb.json.xschema.XConstantField => -1
          }
          case x: net.liftweb.json.xschema.XViewField => v2 match {
            case y: net.liftweb.json.xschema.XRealField => 1
            case y: net.liftweb.json.xschema.XViewField => net.liftweb.json.xschema.Orderings.XViewFieldOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XConstantField => -1
          }
          case x: net.liftweb.json.xschema.XConstantField => v2 match {
            case y: net.liftweb.json.xschema.XRealField => 1
            case y: net.liftweb.json.xschema.XViewField => 1
            case y: net.liftweb.json.xschema.XConstantField => net.liftweb.json.xschema.Orderings.XConstantFieldOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXField(v1: net.liftweb.json.xschema.XField) extends Ordered[net.liftweb.json.xschema.XField] {
      def compare(v2: net.liftweb.json.xschema.XField): Int = XFieldOrdering.compare(v1, v2)
    }
    implicit def XFieldToOrderedXField(v: net.liftweb.json.xschema.XField) = OrderedXField(v)
    
    implicit val XProductOrdering: Ordering[net.liftweb.json.xschema.XProduct] = new Ordering[net.liftweb.json.xschema.XProduct] {
      def compare(v1: net.liftweb.json.xschema.XProduct, v2: net.liftweb.json.xschema.XProduct): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.namespace, v2.namespace) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XFieldOrdering).compare(v1.terms, v2.terms) * 1, empty))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XCoproductOrdering: Ordering[net.liftweb.json.xschema.XCoproduct] = new Ordering[net.liftweb.json.xschema.XCoproduct] {
      def compare(v1: net.liftweb.json.xschema.XCoproduct, v2: net.liftweb.json.xschema.XCoproduct): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.namespace, v2.namespace) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XDefinitionRefOrdering).compare(v1.terms, v2.terms) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.JValueOrdering.compare(v1.default, v2.default) * 1, empty)))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XUnionOrdering: Ordering[net.liftweb.json.xschema.XUnion] = new Ordering[net.liftweb.json.xschema.XUnion] {
      def compare(v1: net.liftweb.json.xschema.XUnion, v2: net.liftweb.json.xschema.XUnion): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.namespace, v2.namespace) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.ListOrdering(net.liftweb.json.xschema.Orderings.XReferenceOrdering).compare(v1.terms, v2.terms) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.JValueOrdering.compare(v1.default, v2.default) * 1, empty)))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XConstantOrdering: Ordering[net.liftweb.json.xschema.XConstant] = new Ordering[net.liftweb.json.xschema.XConstant] {
      def compare(v1: net.liftweb.json.xschema.XConstant, v2: net.liftweb.json.xschema.XConstant): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.namespace, v2.namespace) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.constantType, v2.constantType) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.JValueOrdering.compare(v1.default, v2.default) * 1, empty)))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XRealFieldOrdering: Ordering[net.liftweb.json.xschema.XRealField] = new Ordering[net.liftweb.json.xschema.XRealField] {
      def compare(v1: net.liftweb.json.xschema.XRealField, v2: net.liftweb.json.xschema.XRealField): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.fieldType, v2.fieldType) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.JValueOrdering.compare(v1.default, v2.default) * 1, cons(net.liftweb.json.xschema.Orderings.XOrderOrdering.compare(v1.order, v2.order) * 1, empty)))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XViewFieldOrdering: Ordering[net.liftweb.json.xschema.XViewField] = new Ordering[net.liftweb.json.xschema.XViewField] {
      def compare(v1: net.liftweb.json.xschema.XViewField, v2: net.liftweb.json.xschema.XViewField): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.fieldType, v2.fieldType) * 1, empty)))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XConstantFieldOrdering: Ordering[net.liftweb.json.xschema.XConstantField] = new Ordering[net.liftweb.json.xschema.XConstantField] {
      def compare(v1: net.liftweb.json.xschema.XConstantField, v2: net.liftweb.json.xschema.XConstantField): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = cons(net.liftweb.json.xschema.DefaultOrderings.StringOrdering.compare(v1.name, v2.name) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.MapOrdering(net.liftweb.json.xschema.DefaultOrderings.StringOrdering, net.liftweb.json.xschema.DefaultOrderings.JValueOrdering).compare(v1.properties, v2.properties) * 1, cons(net.liftweb.json.xschema.Orderings.XReferenceOrdering.compare(v1.fieldType, v2.fieldType) * 1, cons(net.liftweb.json.xschema.DefaultOrderings.JValueOrdering.compare(v1.default, v2.default) * 1, empty))))
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XOrderOrdering: Ordering[net.liftweb.json.xschema.XOrder] = new Ordering[net.liftweb.json.xschema.XOrder] {
      def compare(v1: net.liftweb.json.xschema.XOrder, v2: net.liftweb.json.xschema.XOrder): Int = {
        if (v1 == v2) 0
        else v1 match {
          case x: net.liftweb.json.xschema.XOrderAscending.type => v2 match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => net.liftweb.json.xschema.Orderings.XOrderAscendingOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XOrderDescending.type => -1
            case y: net.liftweb.json.xschema.XOrderIgnore.type => -1
          }
          case x: net.liftweb.json.xschema.XOrderDescending.type => v2 match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => 1
            case y: net.liftweb.json.xschema.XOrderDescending.type => net.liftweb.json.xschema.Orderings.XOrderDescendingOrdering.compare(x, y)
            case y: net.liftweb.json.xschema.XOrderIgnore.type => -1
          }
          case x: net.liftweb.json.xschema.XOrderIgnore.type => v2 match {
            case y: net.liftweb.json.xschema.XOrderAscending.type => 1
            case y: net.liftweb.json.xschema.XOrderDescending.type => 1
            case y: net.liftweb.json.xschema.XOrderIgnore.type => net.liftweb.json.xschema.Orderings.XOrderIgnoreOrdering.compare(x, y)
          }
        }
      }
    }
    case class OrderedXOrder(v1: net.liftweb.json.xschema.XOrder) extends Ordered[net.liftweb.json.xschema.XOrder] {
      def compare(v2: net.liftweb.json.xschema.XOrder): Int = XOrderOrdering.compare(v1, v2)
    }
    implicit def XOrderToOrderedXOrder(v: net.liftweb.json.xschema.XOrder) = OrderedXOrder(v)
    
    implicit val XOrderAscendingOrdering: Ordering[net.liftweb.json.xschema.XOrderAscending.type] = new Ordering[net.liftweb.json.xschema.XOrderAscending.type] {
      def compare(v1: net.liftweb.json.xschema.XOrderAscending.type, v2: net.liftweb.json.xschema.XOrderAscending.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XOrderDescendingOrdering: Ordering[net.liftweb.json.xschema.XOrderDescending.type] = new Ordering[net.liftweb.json.xschema.XOrderDescending.type] {
      def compare(v1: net.liftweb.json.xschema.XOrderDescending.type, v2: net.liftweb.json.xschema.XOrderDescending.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
    
    implicit val XOrderIgnoreOrdering: Ordering[net.liftweb.json.xschema.XOrderIgnore.type] = new Ordering[net.liftweb.json.xschema.XOrderIgnore.type] {
      def compare(v1: net.liftweb.json.xschema.XOrderIgnore.type, v2: net.liftweb.json.xschema.XOrderIgnore.type): Int = {
        import Stream.{cons, empty}
        
        return if (v1 == v2) 0 else {      
          val comparisons = empty
          
          comparisons.dropWhile(_ == 0).append(0 :: Nil).first
        }
      }
    }
  }
  object Orderings extends Orderings
  
  sealed trait XSchema extends Product {
    
  }
  
  sealed trait XReference extends Product with net.liftweb.json.xschema.XSchema {
    
  }
  
  sealed trait XPrimitiveRef extends Product with net.liftweb.json.xschema.XReference {
    
  }
  
  sealed trait XContainerRef extends Product with net.liftweb.json.xschema.XReference {
    
  }
  
  sealed trait XCollection extends Product with net.liftweb.json.xschema.XContainerRef {
    def elementType: net.liftweb.json.xschema.XReference
  }
  
  sealed trait XDefinition extends Product with net.liftweb.json.xschema.XSchema {
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef
    def properties: Map[String, net.liftweb.json.JsonAST.JValue]
    def namespace: String
    def name: String
  }
  
  sealed trait XMultitype extends Product with net.liftweb.json.xschema.XDefinition {
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef
    def properties: Map[String, net.liftweb.json.JsonAST.JValue]
    def namespace: String
    def name: String
    def default: net.liftweb.json.JsonAST.JValue
  }
  
  sealed trait XField extends Product with net.liftweb.json.xschema.XSchema {
    def properties: Map[String, net.liftweb.json.JsonAST.JValue]
    def name: String
    def fieldType: net.liftweb.json.xschema.XReference
  }
  
  sealed trait XOrder extends Product {
    
  }
  
  case class XRoot(definitions: List[net.liftweb.json.xschema.XDefinition], constants: List[net.liftweb.json.xschema.XConstant], properties: Map[String, net.liftweb.json.JsonAST.JValue]) extends Ordered[net.liftweb.json.xschema.XRoot] {
    def compare(that: net.liftweb.json.xschema.XRoot): Int = net.liftweb.json.xschema.Orderings.XRootOrdering.compare(this, that)
    
  }
  
  case class XDefinitionRef(name: String, namespace: String) extends Ordered[net.liftweb.json.xschema.XDefinitionRef] with net.liftweb.json.xschema.XReference {
    def compare(that: net.liftweb.json.xschema.XDefinitionRef): Int = net.liftweb.json.xschema.Orderings.XDefinitionRefOrdering.compare(this, that)
    
  }
  
  case object XBoolean extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XInt extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XLong extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XFloat extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XDouble extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XString extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XJSON extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case object XDate extends net.liftweb.json.xschema.XPrimitiveRef 
  
  case class XList(elementType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XList] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XList): Int = net.liftweb.json.xschema.Orderings.XListOrdering.compare(this, that)
    
  }
  
  case class XSet(elementType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XSet] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XSet): Int = net.liftweb.json.xschema.Orderings.XSetOrdering.compare(this, that)
    
  }
  
  case class XArray(elementType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XArray] with net.liftweb.json.xschema.XCollection {
    def compare(that: net.liftweb.json.xschema.XArray): Int = net.liftweb.json.xschema.Orderings.XArrayOrdering.compare(this, that)
    
  }
  
  case class XMap(keyType: net.liftweb.json.xschema.XReference, valueType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XMap] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XMap): Int = net.liftweb.json.xschema.Orderings.XMapOrdering.compare(this, that)
    
  }
  
  case class XOptional(optionalType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XOptional] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XOptional): Int = net.liftweb.json.xschema.Orderings.XOptionalOrdering.compare(this, that)
    
  }
  
  case class XTuple(types: List[net.liftweb.json.xschema.XReference]) extends Ordered[net.liftweb.json.xschema.XTuple] with net.liftweb.json.xschema.XContainerRef {
    def compare(that: net.liftweb.json.xschema.XTuple): Int = net.liftweb.json.xschema.Orderings.XTupleOrdering.compare(this, that)
    
  }
  
  /** A product is analogous to a record: it contains fields, which may be any
   * type, have default values, and have a user-defined ordering. Products are
   * the fundamental building blocks used to construct most data structures.
   */
  case class XProduct(name: String, namespace: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], terms: List[net.liftweb.json.xschema.XField]) extends Ordered[net.liftweb.json.xschema.XProduct] with net.liftweb.json.xschema.XDefinition with net.liftweb.json.xschema.XProductBehavior {
    def compare(that: net.liftweb.json.xschema.XProduct): Int = net.liftweb.json.xschema.Orderings.XProductOrdering.compare(this, that)
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  
  /** A coproduct is a data structure that can assume one of N other types.
   * These types must be either products, or other coproducts -- primitives are
   * not allowed because they cannot be mapped cleanly to most languages (see
   * unions for a disjoint structure that allows primitives). <p> Note that most
   * languages cannot handle coproducts of unions.
   */
  case class XCoproduct(name: String, namespace: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], terms: List[net.liftweb.json.xschema.XDefinitionRef], default: net.liftweb.json.JsonAST.JValue) extends Ordered[net.liftweb.json.xschema.XCoproduct] with net.liftweb.json.xschema.XMultitype {
    def compare(that: net.liftweb.json.xschema.XCoproduct): Int = net.liftweb.json.xschema.Orderings.XCoproductOrdering.compare(this, that)
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  
  /** A union is a C-style union of N types -- referred to as terms. Unlike
   * coproducts, unions have no effect on the type hierarchy of the specified
   * terms, and the terms may include primitive types, in addition to references
   * to products, coproducts, and other unions. Although unions have names and
   * namespaces, most languages do not have explicit support for union types,
   * and in such cases, no entity will be generated for them; they will be
   * translated into the supertype of all the terms. <p>Some code generators may
   * not be able to handle unions or coproducts that contain unions.
   */
  case class XUnion(name: String, namespace: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], terms: List[net.liftweb.json.xschema.XReference], default: net.liftweb.json.JsonAST.JValue) extends Ordered[net.liftweb.json.xschema.XUnion] with net.liftweb.json.xschema.XMultitype {
    def compare(that: net.liftweb.json.xschema.XUnion): Int = net.liftweb.json.xschema.Orderings.XUnionOrdering.compare(this, that)
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  
  case class XConstant(name: String, namespace: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], constantType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue) extends Ordered[net.liftweb.json.xschema.XConstant] with net.liftweb.json.xschema.XSchema {
    def compare(that: net.liftweb.json.xschema.XConstant): Int = net.liftweb.json.xschema.Orderings.XConstantOrdering.compare(this, that)
    def referenceTo: net.liftweb.json.xschema.XDefinitionRef = net.liftweb.json.xschema.XDefinitionRef(name, namespace)
  }
  
  case class XRealField(name: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], fieldType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue, order: net.liftweb.json.xschema.XOrder) extends Ordered[net.liftweb.json.xschema.XRealField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XRealField): Int = net.liftweb.json.xschema.Orderings.XRealFieldOrdering.compare(this, that)
    
  }
  
  case class XViewField(name: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], fieldType: net.liftweb.json.xschema.XReference) extends Ordered[net.liftweb.json.xschema.XViewField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XViewField): Int = net.liftweb.json.xschema.Orderings.XViewFieldOrdering.compare(this, that)
    
  }
  
  case class XConstantField(name: String, properties: Map[String, net.liftweb.json.JsonAST.JValue], fieldType: net.liftweb.json.xschema.XReference, default: net.liftweb.json.JsonAST.JValue) extends Ordered[net.liftweb.json.xschema.XConstantField] with net.liftweb.json.xschema.XField {
    def compare(that: net.liftweb.json.xschema.XConstantField): Int = net.liftweb.json.xschema.Orderings.XConstantFieldOrdering.compare(this, that)
    
  }
  
  case object XOrderAscending extends net.liftweb.json.xschema.XOrder 
  
  case object XOrderDescending extends net.liftweb.json.xschema.XOrder 
  
  case object XOrderIgnore extends net.liftweb.json.xschema.XOrder 
  
  trait Extractors {
    protected def extractField[T](jvalue: JValue, name: String, default: JValue, e: Extractor[T]): T = {
      try {
        e.extract((jvalue \ name -->? classOf[JField]).map(_.value).getOrElse(default))
      }
      catch {
        case _ => e.extract(default)
      }
    }
    
    implicit val XRootExtractor: Extractor[net.liftweb.json.xschema.XRoot] = new Extractor[net.liftweb.json.xschema.XRoot] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XRoot = {
        XRoot(
          extractField[List[net.liftweb.json.xschema.XDefinition]](jvalue, "definitions", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XDefinitionExtractor)),
          extractField[List[net.liftweb.json.xschema.XConstant]](jvalue, "constants", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XConstantExtractor)),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor))
        )
      }
    }
    
    lazy val XSchemaExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XSchema] = ({
      case JField("XDefinition", value) => net.liftweb.json.xschema.Extractors.XDefinitionExtractor.extract(value)
      case JField("XReference", value) => net.liftweb.json.xschema.Extractors.XReferenceExtractor.extract(value)
      case JField("XField", value) => net.liftweb.json.xschema.Extractors.XFieldExtractor.extract(value)
      case JField("XConstant", value) => net.liftweb.json.xschema.Extractors.XConstantExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XSchema]).orElse(net.liftweb.json.xschema.Extractors.XDefinitionExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XReferenceExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XFieldExtractorFunction)
    implicit val XSchemaExtractor: Extractor[net.liftweb.json.xschema.XSchema] = new Extractor[net.liftweb.json.xschema.XSchema] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XSchema = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XSchema] = {
          (jvalue --> classOf[JObject]).obj.filter(XSchemaExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XSchemaExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XSchema, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    lazy val XReferenceExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XReference] = ({
      case JField("XPrimitiveRef", value) => net.liftweb.json.xschema.Extractors.XPrimitiveRefExtractor.extract(value)
      case JField("XContainerRef", value) => net.liftweb.json.xschema.Extractors.XContainerRefExtractor.extract(value)
      case JField("XDefinitionRef", value) => net.liftweb.json.xschema.Extractors.XDefinitionRefExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XReference]).orElse(net.liftweb.json.xschema.Extractors.XPrimitiveRefExtractorFunction).orElse(net.liftweb.json.xschema.Extractors.XContainerRefExtractorFunction)
    implicit val XReferenceExtractor: Extractor[net.liftweb.json.xschema.XReference] = new Extractor[net.liftweb.json.xschema.XReference] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XReference = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XReference] = {
          (jvalue --> classOf[JObject]).obj.filter(XReferenceExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XReferenceExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XReference, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    lazy val XPrimitiveRefExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XPrimitiveRef] = ({
      case JField("XBoolean", value) => net.liftweb.json.xschema.Extractors.XBooleanExtractor.extract(value)
      case JField("XInt", value) => net.liftweb.json.xschema.Extractors.XIntExtractor.extract(value)
      case JField("XLong", value) => net.liftweb.json.xschema.Extractors.XLongExtractor.extract(value)
      case JField("XFloat", value) => net.liftweb.json.xschema.Extractors.XFloatExtractor.extract(value)
      case JField("XDouble", value) => net.liftweb.json.xschema.Extractors.XDoubleExtractor.extract(value)
      case JField("XString", value) => net.liftweb.json.xschema.Extractors.XStringExtractor.extract(value)
      case JField("XJSON", value) => net.liftweb.json.xschema.Extractors.XJSONExtractor.extract(value)
      case JField("XDate", value) => net.liftweb.json.xschema.Extractors.XDateExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XPrimitiveRef])
    implicit val XPrimitiveRefExtractor: Extractor[net.liftweb.json.xschema.XPrimitiveRef] = new Extractor[net.liftweb.json.xschema.XPrimitiveRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XPrimitiveRef = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XPrimitiveRef] = {
          (jvalue --> classOf[JObject]).obj.filter(XPrimitiveRefExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XPrimitiveRefExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XString",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XPrimitiveRef, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    lazy val XContainerRefExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XContainerRef] = ({
      case JField("XCollection", value) => net.liftweb.json.xschema.Extractors.XCollectionExtractor.extract(value)
      case JField("XMap", value) => net.liftweb.json.xschema.Extractors.XMapExtractor.extract(value)
      case JField("XOptional", value) => net.liftweb.json.xschema.Extractors.XOptionalExtractor.extract(value)
      case JField("XTuple", value) => net.liftweb.json.xschema.Extractors.XTupleExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XContainerRef]).orElse(net.liftweb.json.xschema.Extractors.XCollectionExtractorFunction)
    implicit val XContainerRefExtractor: Extractor[net.liftweb.json.xschema.XContainerRef] = new Extractor[net.liftweb.json.xschema.XContainerRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XContainerRef = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XContainerRef] = {
          (jvalue --> classOf[JObject]).obj.filter(XContainerRefExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XContainerRefExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XContainerRef, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XDefinitionRefExtractor: Extractor[net.liftweb.json.xschema.XDefinitionRef] = new Extractor[net.liftweb.json.xschema.XDefinitionRef] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDefinitionRef = {
        XDefinitionRef(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor)
        )
      }
    }
    
    implicit val XBooleanExtractor: Extractor[net.liftweb.json.xschema.XBoolean.type] = new Extractor[net.liftweb.json.xschema.XBoolean.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XBoolean.type = {
        XBoolean
      }
    }
    
    implicit val XIntExtractor: Extractor[net.liftweb.json.xschema.XInt.type] = new Extractor[net.liftweb.json.xschema.XInt.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XInt.type = {
        XInt
      }
    }
    
    implicit val XLongExtractor: Extractor[net.liftweb.json.xschema.XLong.type] = new Extractor[net.liftweb.json.xschema.XLong.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XLong.type = {
        XLong
      }
    }
    
    implicit val XFloatExtractor: Extractor[net.liftweb.json.xschema.XFloat.type] = new Extractor[net.liftweb.json.xschema.XFloat.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XFloat.type = {
        XFloat
      }
    }
    
    implicit val XDoubleExtractor: Extractor[net.liftweb.json.xschema.XDouble.type] = new Extractor[net.liftweb.json.xschema.XDouble.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDouble.type = {
        XDouble
      }
    }
    
    implicit val XStringExtractor: Extractor[net.liftweb.json.xschema.XString.type] = new Extractor[net.liftweb.json.xschema.XString.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XString.type = {
        XString
      }
    }
    
    implicit val XJSONExtractor: Extractor[net.liftweb.json.xschema.XJSON.type] = new Extractor[net.liftweb.json.xschema.XJSON.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XJSON.type = {
        XJSON
      }
    }
    
    implicit val XDateExtractor: Extractor[net.liftweb.json.xschema.XDate.type] = new Extractor[net.liftweb.json.xschema.XDate.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDate.type = {
        XDate
      }
    }
    
    lazy val XCollectionExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XCollection] = ({
      case JField("XList", value) => net.liftweb.json.xschema.Extractors.XListExtractor.extract(value)
      case JField("XSet", value) => net.liftweb.json.xschema.Extractors.XSetExtractor.extract(value)
      case JField("XArray", value) => net.liftweb.json.xschema.Extractors.XArrayExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XCollection])
    implicit val XCollectionExtractor: Extractor[net.liftweb.json.xschema.XCollection] = new Extractor[net.liftweb.json.xschema.XCollection] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XCollection = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XCollection] = {
          (jvalue --> classOf[JObject]).obj.filter(XCollectionExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XCollectionExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XList",JObject(JField("elementType",JObject(JField("XString",JObject(Nil))::Nil))::Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XCollection, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XListExtractor: Extractor[net.liftweb.json.xschema.XList] = new Extractor[net.liftweb.json.xschema.XList] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XList = {
        XList(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XSetExtractor: Extractor[net.liftweb.json.xschema.XSet] = new Extractor[net.liftweb.json.xschema.XSet] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XSet = {
        XSet(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XArrayExtractor: Extractor[net.liftweb.json.xschema.XArray] = new Extractor[net.liftweb.json.xschema.XArray] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XArray = {
        XArray(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "elementType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XMapExtractor: Extractor[net.liftweb.json.xschema.XMap] = new Extractor[net.liftweb.json.xschema.XMap] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XMap = {
        XMap(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "keyType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "valueType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XOptionalExtractor: Extractor[net.liftweb.json.xschema.XOptional] = new Extractor[net.liftweb.json.xschema.XOptional] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOptional = {
        XOptional(
          extractField[net.liftweb.json.xschema.XReference](jvalue, "optionalType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XTupleExtractor: Extractor[net.liftweb.json.xschema.XTuple] = new Extractor[net.liftweb.json.xschema.XTuple] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XTuple = {
        XTuple(
          extractField[List[net.liftweb.json.xschema.XReference]](jvalue, "types", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XReferenceExtractor))
        )
      }
    }
    
    lazy val XDefinitionExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XDefinition] = ({
      case JField("XProduct", value) => net.liftweb.json.xschema.Extractors.XProductExtractor.extract(value)
      case JField("XMultitype", value) => net.liftweb.json.xschema.Extractors.XMultitypeExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XDefinition]).orElse(net.liftweb.json.xschema.Extractors.XMultitypeExtractorFunction)
    implicit val XDefinitionExtractor: Extractor[net.liftweb.json.xschema.XDefinition] = new Extractor[net.liftweb.json.xschema.XDefinition] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XDefinition = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XDefinition] = {
          (jvalue --> classOf[JObject]).obj.filter(XDefinitionExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XDefinitionExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XProduct",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XDefinition, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    lazy val XMultitypeExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XMultitype] = ({
      case JField("XCoproduct", value) => net.liftweb.json.xschema.Extractors.XCoproductExtractor.extract(value)
      case JField("XUnion", value) => net.liftweb.json.xschema.Extractors.XUnionExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XMultitype])
    implicit val XMultitypeExtractor: Extractor[net.liftweb.json.xschema.XMultitype] = new Extractor[net.liftweb.json.xschema.XMultitype] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XMultitype = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XMultitype] = {
          (jvalue --> classOf[JObject]).obj.filter(XMultitypeExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XMultitypeExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XCoproduct",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XMultitype, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    lazy val XFieldExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XField] = ({
      case JField("XRealField", value) => net.liftweb.json.xschema.Extractors.XRealFieldExtractor.extract(value)
      case JField("XViewField", value) => net.liftweb.json.xschema.Extractors.XViewFieldExtractor.extract(value)
      case JField("XConstantField", value) => net.liftweb.json.xschema.Extractors.XConstantFieldExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XField])
    implicit val XFieldExtractor: Extractor[net.liftweb.json.xschema.XField] = new Extractor[net.liftweb.json.xschema.XField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XField = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XField] = {
          (jvalue --> classOf[JObject]).obj.filter(XFieldExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XFieldExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XRealField",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XField, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XProductExtractor: Extractor[net.liftweb.json.xschema.XProduct] = new Extractor[net.liftweb.json.xschema.XProduct] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XProduct = {
        XProduct(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[List[net.liftweb.json.xschema.XField]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XFieldExtractor))
        )
      }
    }
    
    implicit val XCoproductExtractor: Extractor[net.liftweb.json.xschema.XCoproduct] = new Extractor[net.liftweb.json.xschema.XCoproduct] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XCoproduct = {
        XCoproduct(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[List[net.liftweb.json.xschema.XDefinitionRef]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XDefinitionRefExtractor)),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XUnionExtractor: Extractor[net.liftweb.json.xschema.XUnion] = new Extractor[net.liftweb.json.xschema.XUnion] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XUnion = {
        XUnion(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[List[net.liftweb.json.xschema.XReference]](jvalue, "terms", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.ListExtractor(net.liftweb.json.xschema.Extractors.XReferenceExtractor)),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XConstantExtractor: Extractor[net.liftweb.json.xschema.XConstant] = new Extractor[net.liftweb.json.xschema.XConstant] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XConstant = {
        XConstant(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[String](jvalue, "namespace", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "constantType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    implicit val XRealFieldExtractor: Extractor[net.liftweb.json.xschema.XRealField] = new Extractor[net.liftweb.json.xschema.XRealField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XRealField = {
        XRealField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor),
          extractField[net.liftweb.json.xschema.XOrder](jvalue, "order", JObject(JField("XOrderAscending",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XOrderExtractor)
        )
      }
    }
    
    implicit val XViewFieldExtractor: Extractor[net.liftweb.json.xschema.XViewField] = new Extractor[net.liftweb.json.xschema.XViewField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XViewField = {
        XViewField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XDefinitionRef",JObject(JField("name",JString(""))::JField("namespace",JString(""))::Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor)
        )
      }
    }
    
    implicit val XConstantFieldExtractor: Extractor[net.liftweb.json.xschema.XConstantField] = new Extractor[net.liftweb.json.xschema.XConstantField] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XConstantField = {
        XConstantField(
          extractField[String](jvalue, "name", JString(""), net.liftweb.json.xschema.DefaultExtractors.StringExtractor),
          extractField[Map[String, net.liftweb.json.JsonAST.JValue]](jvalue, "properties", JArray(Nil), net.liftweb.json.xschema.DefaultExtractors.MapExtractor(net.liftweb.json.xschema.DefaultExtractors.StringExtractor, net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)),
          extractField[net.liftweb.json.xschema.XReference](jvalue, "fieldType", JObject(JField("XString",JObject(Nil))::Nil), net.liftweb.json.xschema.Extractors.XReferenceExtractor),
          extractField[net.liftweb.json.JsonAST.JValue](jvalue, "default", JString(""), net.liftweb.json.xschema.DefaultExtractors.JValueExtractor)
        )
      }
    }
    
    lazy val XOrderExtractorFunction: PartialFunction[JField, net.liftweb.json.xschema.XOrder] = ({
      case JField("XOrderAscending", value) => net.liftweb.json.xschema.Extractors.XOrderAscendingExtractor.extract(value)
      case JField("XOrderDescending", value) => net.liftweb.json.xschema.Extractors.XOrderDescendingExtractor.extract(value)
      case JField("XOrderIgnore", value) => net.liftweb.json.xschema.Extractors.XOrderIgnoreExtractor.extract(value)
    }: PartialFunction[JField, net.liftweb.json.xschema.XOrder])
    implicit val XOrderExtractor: Extractor[net.liftweb.json.xschema.XOrder] = new Extractor[net.liftweb.json.xschema.XOrder] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrder = {
        def extract0(jvalue: JValue): Option[net.liftweb.json.xschema.XOrder] = {
          (jvalue --> classOf[JObject]).obj.filter(XOrderExtractorFunction.isDefinedAt _) match {
            case field :: fields => Some(XOrderExtractorFunction(field))
            case Nil => None
          }
        }
        
        extract0(jvalue) match {
          case Some(v) => v
          case None => extract0(JObject(JField("XOrderAscending",JObject(Nil))::Nil)) match {
            case Some(v) => v
            case None => error("Expected to find net.liftweb.json.xschema.XOrder, but found " + jvalue + ", and default value was invalid")
          }
        }
      }
    }
    
    implicit val XOrderAscendingExtractor: Extractor[net.liftweb.json.xschema.XOrderAscending.type] = new Extractor[net.liftweb.json.xschema.XOrderAscending.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderAscending.type = {
        XOrderAscending
      }
    }
    
    implicit val XOrderDescendingExtractor: Extractor[net.liftweb.json.xschema.XOrderDescending.type] = new Extractor[net.liftweb.json.xschema.XOrderDescending.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderDescending.type = {
        XOrderDescending
      }
    }
    
    implicit val XOrderIgnoreExtractor: Extractor[net.liftweb.json.xschema.XOrderIgnore.type] = new Extractor[net.liftweb.json.xschema.XOrderIgnore.type] {
      def extract(jvalue: JValue): net.liftweb.json.xschema.XOrderIgnore.type = {
        XOrderIgnore
      }
    }
  }
  object Extractors extends Extractors
  
  trait Decomposers {
    implicit val XRootDecomposer: Decomposer[net.liftweb.json.xschema.XRoot] = new Decomposer[net.liftweb.json.xschema.XRoot] {
      def decompose(tvalue: net.liftweb.json.xschema.XRoot): JValue = {
        JObject(
          JField("definitions", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XDefinitionDecomposer).decompose(tvalue.definitions)) ::
          JField("constants", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XConstantDecomposer).decompose(tvalue.constants)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) :: Nil
        )
      }
    }
    
    implicit val XSchemaDecomposer: Decomposer[net.liftweb.json.xschema.XSchema] = new Decomposer[net.liftweb.json.xschema.XSchema] {
      def decompose(tvalue: net.liftweb.json.xschema.XSchema): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XProduct => JObject(JField("XProduct", net.liftweb.json.xschema.Decomposers.XProductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDate.type => JObject(JField("XDate", net.liftweb.json.xschema.Decomposers.XDateDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDefinitionRef => JObject(JField("XDefinitionRef", net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XRealField => JObject(JField("XRealField", net.liftweb.json.xschema.Decomposers.XRealFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XViewField => JObject(JField("XViewField", net.liftweb.json.xschema.Decomposers.XViewFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstantField => JObject(JField("XConstantField", net.liftweb.json.xschema.Decomposers.XConstantFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstant => JObject(JField("XConstant", net.liftweb.json.xschema.Decomposers.XConstantDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XReferenceDecomposer: Decomposer[net.liftweb.json.xschema.XReference] = new Decomposer[net.liftweb.json.xschema.XReference] {
      def decompose(tvalue: net.liftweb.json.xschema.XReference): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDate.type => JObject(JField("XDate", net.liftweb.json.xschema.Decomposers.XDateDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDefinitionRef => JObject(JField("XDefinitionRef", net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XPrimitiveRefDecomposer: Decomposer[net.liftweb.json.xschema.XPrimitiveRef] = new Decomposer[net.liftweb.json.xschema.XPrimitiveRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XPrimitiveRef): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XBoolean.type => JObject(JField("XBoolean", net.liftweb.json.xschema.Decomposers.XBooleanDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XInt.type => JObject(JField("XInt", net.liftweb.json.xschema.Decomposers.XIntDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XLong.type => JObject(JField("XLong", net.liftweb.json.xschema.Decomposers.XLongDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XFloat.type => JObject(JField("XFloat", net.liftweb.json.xschema.Decomposers.XFloatDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDouble.type => JObject(JField("XDouble", net.liftweb.json.xschema.Decomposers.XDoubleDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XString.type => JObject(JField("XString", net.liftweb.json.xschema.Decomposers.XStringDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XJSON.type => JObject(JField("XJSON", net.liftweb.json.xschema.Decomposers.XJSONDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XDate.type => JObject(JField("XDate", net.liftweb.json.xschema.Decomposers.XDateDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XContainerRefDecomposer: Decomposer[net.liftweb.json.xschema.XContainerRef] = new Decomposer[net.liftweb.json.xschema.XContainerRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XContainerRef): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XMap => JObject(JField("XMap", net.liftweb.json.xschema.Decomposers.XMapDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOptional => JObject(JField("XOptional", net.liftweb.json.xschema.Decomposers.XOptionalDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XTuple => JObject(JField("XTuple", net.liftweb.json.xschema.Decomposers.XTupleDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XDefinitionRefDecomposer: Decomposer[net.liftweb.json.xschema.XDefinitionRef] = new Decomposer[net.liftweb.json.xschema.XDefinitionRef] {
      def decompose(tvalue: net.liftweb.json.xschema.XDefinitionRef): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) :: Nil
        )
      }
    }
    
    implicit val XBooleanDecomposer: Decomposer[net.liftweb.json.xschema.XBoolean.type] = new Decomposer[net.liftweb.json.xschema.XBoolean.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XBoolean.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XIntDecomposer: Decomposer[net.liftweb.json.xschema.XInt.type] = new Decomposer[net.liftweb.json.xschema.XInt.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XInt.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XLongDecomposer: Decomposer[net.liftweb.json.xschema.XLong.type] = new Decomposer[net.liftweb.json.xschema.XLong.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XLong.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XFloatDecomposer: Decomposer[net.liftweb.json.xschema.XFloat.type] = new Decomposer[net.liftweb.json.xschema.XFloat.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XFloat.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XDoubleDecomposer: Decomposer[net.liftweb.json.xschema.XDouble.type] = new Decomposer[net.liftweb.json.xschema.XDouble.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XDouble.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XStringDecomposer: Decomposer[net.liftweb.json.xschema.XString.type] = new Decomposer[net.liftweb.json.xschema.XString.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XString.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XJSONDecomposer: Decomposer[net.liftweb.json.xschema.XJSON.type] = new Decomposer[net.liftweb.json.xschema.XJSON.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XJSON.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XDateDecomposer: Decomposer[net.liftweb.json.xschema.XDate.type] = new Decomposer[net.liftweb.json.xschema.XDate.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XDate.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XCollectionDecomposer: Decomposer[net.liftweb.json.xschema.XCollection] = new Decomposer[net.liftweb.json.xschema.XCollection] {
      def decompose(tvalue: net.liftweb.json.xschema.XCollection): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XList => JObject(JField("XList", net.liftweb.json.xschema.Decomposers.XListDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XSet => JObject(JField("XSet", net.liftweb.json.xschema.Decomposers.XSetDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XArray => JObject(JField("XArray", net.liftweb.json.xschema.Decomposers.XArrayDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XListDecomposer: Decomposer[net.liftweb.json.xschema.XList] = new Decomposer[net.liftweb.json.xschema.XList] {
      def decompose(tvalue: net.liftweb.json.xschema.XList): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XSetDecomposer: Decomposer[net.liftweb.json.xschema.XSet] = new Decomposer[net.liftweb.json.xschema.XSet] {
      def decompose(tvalue: net.liftweb.json.xschema.XSet): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XArrayDecomposer: Decomposer[net.liftweb.json.xschema.XArray] = new Decomposer[net.liftweb.json.xschema.XArray] {
      def decompose(tvalue: net.liftweb.json.xschema.XArray): JValue = {
        JObject(
          JField("elementType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.elementType)) :: Nil
        )
      }
    }
    
    implicit val XMapDecomposer: Decomposer[net.liftweb.json.xschema.XMap] = new Decomposer[net.liftweb.json.xschema.XMap] {
      def decompose(tvalue: net.liftweb.json.xschema.XMap): JValue = {
        JObject(
          JField("keyType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.keyType)) ::
          JField("valueType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.valueType)) :: Nil
        )
      }
    }
    
    implicit val XOptionalDecomposer: Decomposer[net.liftweb.json.xschema.XOptional] = new Decomposer[net.liftweb.json.xschema.XOptional] {
      def decompose(tvalue: net.liftweb.json.xschema.XOptional): JValue = {
        JObject(
          JField("optionalType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.optionalType)) :: Nil
        )
      }
    }
    
    implicit val XTupleDecomposer: Decomposer[net.liftweb.json.xschema.XTuple] = new Decomposer[net.liftweb.json.xschema.XTuple] {
      def decompose(tvalue: net.liftweb.json.xschema.XTuple): JValue = {
        JObject(
          JField("types", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XReferenceDecomposer).decompose(tvalue.types)) :: Nil
        )
      }
    }
    
    implicit val XDefinitionDecomposer: Decomposer[net.liftweb.json.xschema.XDefinition] = new Decomposer[net.liftweb.json.xschema.XDefinition] {
      def decompose(tvalue: net.liftweb.json.xschema.XDefinition): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XProduct => JObject(JField("XProduct", net.liftweb.json.xschema.Decomposers.XProductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XMultitypeDecomposer: Decomposer[net.liftweb.json.xschema.XMultitype] = new Decomposer[net.liftweb.json.xschema.XMultitype] {
      def decompose(tvalue: net.liftweb.json.xschema.XMultitype): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XCoproduct => JObject(JField("XCoproduct", net.liftweb.json.xschema.Decomposers.XCoproductDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XUnion => JObject(JField("XUnion", net.liftweb.json.xschema.Decomposers.XUnionDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XFieldDecomposer: Decomposer[net.liftweb.json.xschema.XField] = new Decomposer[net.liftweb.json.xschema.XField] {
      def decompose(tvalue: net.liftweb.json.xschema.XField): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XRealField => JObject(JField("XRealField", net.liftweb.json.xschema.Decomposers.XRealFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XViewField => JObject(JField("XViewField", net.liftweb.json.xschema.Decomposers.XViewFieldDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XConstantField => JObject(JField("XConstantField", net.liftweb.json.xschema.Decomposers.XConstantFieldDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XProductDecomposer: Decomposer[net.liftweb.json.xschema.XProduct] = new Decomposer[net.liftweb.json.xschema.XProduct] {
      def decompose(tvalue: net.liftweb.json.xschema.XProduct): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XFieldDecomposer).decompose(tvalue.terms)) :: Nil
        )
      }
    }
    
    implicit val XCoproductDecomposer: Decomposer[net.liftweb.json.xschema.XCoproduct] = new Decomposer[net.liftweb.json.xschema.XCoproduct] {
      def decompose(tvalue: net.liftweb.json.xschema.XCoproduct): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XDefinitionRefDecomposer).decompose(tvalue.terms)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XUnionDecomposer: Decomposer[net.liftweb.json.xschema.XUnion] = new Decomposer[net.liftweb.json.xschema.XUnion] {
      def decompose(tvalue: net.liftweb.json.xschema.XUnion): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("terms", net.liftweb.json.xschema.DefaultDecomposers.ListDecomposer(net.liftweb.json.xschema.Decomposers.XReferenceDecomposer).decompose(tvalue.terms)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XConstantDecomposer: Decomposer[net.liftweb.json.xschema.XConstant] = new Decomposer[net.liftweb.json.xschema.XConstant] {
      def decompose(tvalue: net.liftweb.json.xschema.XConstant): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("namespace", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.namespace)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("constantType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.constantType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XRealFieldDecomposer: Decomposer[net.liftweb.json.xschema.XRealField] = new Decomposer[net.liftweb.json.xschema.XRealField] {
      def decompose(tvalue: net.liftweb.json.xschema.XRealField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) ::
          JField("order", net.liftweb.json.xschema.Decomposers.XOrderDecomposer.decompose(tvalue.order)) :: Nil
        )
      }
    }
    
    implicit val XViewFieldDecomposer: Decomposer[net.liftweb.json.xschema.XViewField] = new Decomposer[net.liftweb.json.xschema.XViewField] {
      def decompose(tvalue: net.liftweb.json.xschema.XViewField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) :: Nil
        )
      }
    }
    
    implicit val XConstantFieldDecomposer: Decomposer[net.liftweb.json.xschema.XConstantField] = new Decomposer[net.liftweb.json.xschema.XConstantField] {
      def decompose(tvalue: net.liftweb.json.xschema.XConstantField): JValue = {
        JObject(
          JField("name", net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer.decompose(tvalue.name)) ::
          JField("properties", net.liftweb.json.xschema.DefaultDecomposers.MapDecomposer(net.liftweb.json.xschema.DefaultDecomposers.StringDecomposer, net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer).decompose(tvalue.properties)) ::
          JField("fieldType", net.liftweb.json.xschema.Decomposers.XReferenceDecomposer.decompose(tvalue.fieldType)) ::
          JField("default", net.liftweb.json.xschema.DefaultDecomposers.JValueDecomposer.decompose(tvalue.default)) :: Nil
        )
      }
    }
    
    implicit val XOrderDecomposer: Decomposer[net.liftweb.json.xschema.XOrder] = new Decomposer[net.liftweb.json.xschema.XOrder] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrder): JValue = {
        tvalue match {
          case x: net.liftweb.json.xschema.XOrderAscending.type => JObject(JField("XOrderAscending", net.liftweb.json.xschema.Decomposers.XOrderAscendingDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOrderDescending.type => JObject(JField("XOrderDescending", net.liftweb.json.xschema.Decomposers.XOrderDescendingDecomposer.decompose(x)) :: Nil)
          case x: net.liftweb.json.xschema.XOrderIgnore.type => JObject(JField("XOrderIgnore", net.liftweb.json.xschema.Decomposers.XOrderIgnoreDecomposer.decompose(x)) :: Nil)
        }
      }
    }
    
    implicit val XOrderAscendingDecomposer: Decomposer[net.liftweb.json.xschema.XOrderAscending.type] = new Decomposer[net.liftweb.json.xschema.XOrderAscending.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderAscending.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XOrderDescendingDecomposer: Decomposer[net.liftweb.json.xschema.XOrderDescending.type] = new Decomposer[net.liftweb.json.xschema.XOrderDescending.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderDescending.type): JValue = {
        JObject(
           Nil
        )
      }
    }
    
    implicit val XOrderIgnoreDecomposer: Decomposer[net.liftweb.json.xschema.XOrderIgnore.type] = new Decomposer[net.liftweb.json.xschema.XOrderIgnore.type] {
      def decompose(tvalue: net.liftweb.json.xschema.XOrderIgnore.type): JValue = {
        JObject(
           Nil
        )
      }
    }
  }
  object Decomposers extends Decomposers
  
  object Serialization extends Decomposers with Extractors with SerializationImplicits {
    
  }
  
  object Constants {
    import Serialization._
    
    
  }
}